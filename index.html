<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2025 bon-soleil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project includes code from the following third-party libraries:

1. **lit (by Google LLC)**
   License: BSD 3-Clause

   Copyright 2017 Google LLC  
   SPDX-License-Identifier: BSD-3-Clause

   https://github.com/lit/lit/blob/main/LICENSE

2. **Three.js**
   License: MIT License

   Copyright 2010-2024 Three.js Authors  
   SPDX-License-Identifier: MIT


-->
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer</title>
    <script type="module" src="./model-viewer.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background-color: #000000;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background-color: #000000;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: #000000;
        --progress-bar-color: #007bff;
        --progress-mask: transparent;
        display: block;
        background-color: var(--poster-color);
      }

      /* カスタムプログレスバー */
      .custom-progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .progress-text {
        font-size: 14px;
        color: #333;
        font-weight: 500;
      }

      .progress-bar-track {
        width: 200px;
        height: 6px;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
        width: 0%;
      }

      .progress-percent {
        font-size: 12px;
        color: #666;
        font-weight: 500;
      }

      @keyframes progressPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* ライトコントロールボタン */
      .light-control-button {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .light-control-button svg {
        width: 28px;
        height: 28px;
        fill: #333;
      }

      .light-control-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* ライトコントロールパネル */
      .light-controls {
        position: absolute;
        top: 15px;
        right: 65px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 100;
        min-width: 200px;
        display: none;
      }

      .control-group {
        margin-bottom: 12px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .preset-buttons {
        display: flex;
        gap: 5px;
        margin-top: 10px;
      }

      .preset-button {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preset-button:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }

      /* 背景切り替えボタン */
      .background-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .bg-button {
        width: 32px;
        height: 32px;
        border: 2px solid #ddd;
        border-radius: 50%;
        background: transparent;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .bg-button.active {
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
      }

      .bg-button:hover {
        border-color: #007bff;
        transform: scale(1.1);
      }

      .bg-black {
        background: #000;
      }

      .bg-white {
        background: #fff;
        border-color: #ccc;
      }

      .bg-white.active {
        border-color: #007bff;
      }

      /* コントロールヒント */
      .controls-hint {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .container:hover .controls-hint {
        opacity: 1;
      }

      .controls-hint p {
        margin: 0;
        opacity: 0.9;
      }

      /* エラー表示 */
      .error-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 300px;
        padding: 40px 20px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-text {
        max-width: 400px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc3545;
        margin: 0 0 8px 0;
      }

      .error-message {
        font-size: 14px;
        color: #666;
        margin: 0 0 20px 0;
        line-height: 1.4;
      }

      .viewer-link {
        display: inline-block;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.2s;
      }

      .viewer-link:hover {
        background-color: #0056b3;
        color: white;
        text-decoration: none;
      }

      /* モバイル対応 */
      @media (max-width: 768px) {
        .light-controls {
          right: 10px;
          top: 65px;
          min-width: 180px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- モデルビューアー -->
      <model-viewer
        id="modelViewer"
        alt="goodsun | bon-soleil"
        camera-controls
        loading="eager"
        reveal="auto"
        exposure="0.7"
        shadow-intensity="0.7"
        shadow-softness="0.3"
        style="--poster-color: #000000; background-color: #000000"
        camera-orbit="0deg 75deg 105%"
        field-of-view="30deg"
        min-camera-orbit="auto auto auto"
        max-camera-orbit="auto auto auto"
        min-field-of-view="10deg"
        max-field-of-view="45deg"
        autoplay
        animation-crossfade-duration="300ms"
      >
        <!-- プログレスバーを無効化 -->
        <div slot="progress-bar"></div>

        <!-- カスタムプログレスバー -->
        <div class="custom-progress-bar" id="customProgressBar">
          <div class="progress-text">Loading 3D Model...</div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
          <div class="progress-percent" id="progressPercent">0%</div>
        </div>
      </model-viewer>

      <!-- ライトコントロールボタン -->
      <button
        class="light-control-button"
        id="lightControlButton"
        title="Light Controls"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
          />
        </svg>
      </button>

      <!-- ライトコントロールパネル -->
      <div class="light-controls" id="lightControls">
        <div class="control-group">
          <label class="control-label">
            Brightness: <span id="exposureValue">70</span>%
          </label>
          <input
            type="range"
            min="0.1"
            max="2.0"
            step="0.1"
            value="0.7"
            id="exposureSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">
            Shadow: <span id="shadowValue">70</span>%
          </label>
          <input
            type="range"
            min="0"
            max="2.0"
            step="0.1"
            value="0.7"
            id="shadowSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">Background</label>
          <div class="background-toggle">
            <button
              id="bgBlackBtn"
              class="bg-button bg-black active"
              title="Black background"
            >
              ⚫
            </button>
            <button
              id="bgWhiteBtn"
              class="bg-button bg-white"
              title="White background"
            >
              ⚪
            </button>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-button" onclick="setPreset(0.5, 0.3)">
            Dim
          </button>
          <button class="preset-button" onclick="setPreset(0.7, 0.7)">
            Normal
          </button>
          <button class="preset-button" onclick="setPreset(1.5, 1.2)">
            Bright
          </button>
        </div>
      </div>

      <!-- コントロールヒント -->
      <div class="controls-hint">
        <p>Drag to rotate • Scroll to zoom • Right-click to pan</p>
      </div>
    </div>

    <script>
      const modelViewer = document.getElementById("modelViewer");
      const lightControlButton = document.getElementById("lightControlButton");
      const lightControls = document.getElementById("lightControls");
      const customProgressBar = document.getElementById("customProgressBar");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPercent = document.getElementById("progressPercent");
      const exposureSlider = document.getElementById("exposureSlider");
      const shadowSlider = document.getElementById("shadowSlider");
      const exposureValue = document.getElementById("exposureValue");
      const shadowValue = document.getElementById("shadowValue");
      const bgBlackBtn = document.getElementById("bgBlackBtn");
      const bgWhiteBtn = document.getElementById("bgWhiteBtn");

      let showControls = false;
      let currentBackgroundColor = "black";

      // ライトコントロールの表示/非表示
      lightControlButton.addEventListener("click", () => {
        showControls = !showControls;
        lightControls.style.display = showControls ? "block" : "none";
      });

      // モデル読み込み完了
      modelViewer.addEventListener("load", () => {
        console.log("Model loaded successfully");
        updateBackgroundColor();
        
        // 裏面に色をつける - 複数のアプローチを順次試行
        setTimeout(() => {
          addBackfaceColorSimple();
        }, 500);
      });

      modelViewer.addEventListener("error", (event) => {
        console.error("Model loading error:", event.detail);
        customProgressBar.style.display = "none";

        // エラー表示
        let errorMsg = "Failed to load 3D model";
        if (event.detail) {
          if (event.detail.type === "loadfailure") {
            errorMsg = "Model file is corrupted or incompatible";
          } else if (event.detail.sourceError) {
            const sourceError = event.detail.sourceError;
            if (
              sourceError.message &&
              sourceError.message.includes("Invalid typed array length")
            ) {
              errorMsg = "Model file is too large for browser memory";
            } else if (
              sourceError.message &&
              sourceError.message.includes("texture")
            ) {
              errorMsg = "Failed to load model textures";
            }
          }
        }

        showError(errorMsg, modelViewer.src);
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        console.log(`Loading progress: ${(progress * 100).toFixed(1)}%`);

        progressBarFill.style.width = `${progress * 100}%`;
        progressPercent.textContent = `${Math.round(progress * 100)}%`;

        // 100%になったら即座に非表示
        if (progress >= 1.0) {
          customProgressBar.style.display = "none";
        } else {
          customProgressBar.style.display = "flex";
        }
      });

      // スライダーイベント
      exposureSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.exposure = value;
        exposureValue.textContent = Math.round(value * 100);
      });

      shadowSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.shadowIntensity = value;
        shadowValue.textContent = Math.round(value * 100);
      });

      // 背景色変更
      bgBlackBtn.addEventListener("click", () => {
        currentBackgroundColor = "black";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      bgWhiteBtn.addEventListener("click", () => {
        currentBackgroundColor = "white";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      function updateBackgroundButtons() {
        bgBlackBtn.classList.toggle(
          "active",
          currentBackgroundColor === "black"
        );
        bgWhiteBtn.classList.toggle(
          "active",
          currentBackgroundColor === "white"
        );
      }

      function updateBackgroundColor() {
        const bgColor =
          currentBackgroundColor === "black" ? "#000000" : "#ffffff";
        modelViewer.style.setProperty("--poster-color", bgColor);
        modelViewer.style.backgroundColor = bgColor;

        // Shadow rootのcanvasにも適用
        setTimeout(() => {
          const shadowRoot = modelViewer.shadowRoot;
          if (shadowRoot) {
            const canvas = shadowRoot.querySelector("canvas");
            if (canvas) {
              canvas.style.backgroundColor = bgColor;
            }
          }
        }, 100);
      }

      // プリセット設定
      function setPreset(exposure, shadow) {
        exposureSlider.value = exposure;
        shadowSlider.value = shadow;
        modelViewer.exposure = exposure;
        modelViewer.shadowIntensity = shadow;
        exposureValue.textContent = Math.round(exposure * 100);
        shadowValue.textContent = Math.round(shadow * 100);
      }

      // サンプルモデル読み込み
      function loadSampleModel(url) {
        console.log("Loading model:", url);
        modelViewer.src = url;
        customProgressBar.style.display = "flex";
        clearError();
      }

      // エラー表示
      function showError(message, modelUrl) {
        const container = document.querySelector(".container");
        const viewerUrl = `/index.html?src=${encodeURIComponent(
          modelUrl
        )}`;
        container.innerHTML = `
                <div class="error-display">
                    <div class="error-icon">⚠️</div>
                    <div class="error-text">
                        <p class="error-title">3D Model Error</p>
                        <p class="error-message">${message}</p>
                        <a href="${viewerUrl}" target="_blank" rel="noopener noreferrer" class="viewer-link">
                            Display Standalone Viewer
                        </a>
                    </div>
                </div>
            `;
      }

      function clearError() {
        // エラー表示をクリア（必要に応じて実装）
      }
      
      // シンプルなアプローチで裏面に色をつける
      function addBackfaceColorSimple() {
        console.log("🎯 Starting simple backface color approach...");
        
        // CSS/WebGLでのグローバルアプローチ
        try {
          // 1. CSSでのアプローチ（制限はあるが試してみる）
          const style = document.createElement('style');
          style.textContent = `
            model-viewer {
              --model-viewer-backface-color: #ff0000;
            }
          `;
          document.head.appendChild(style);
          console.log("✓ CSS backface style added");
          
        } catch (error) {
          console.log("CSS approach failed:", error);
        }
        
        // 2. model-viewerのイベントとAPIを使用
        modelViewer.addEventListener('model-visibility', () => {
          console.log("Model visibility changed, trying direct access...");
          tryDirectAccess();
        });
        
        // 3. 強制的にシーンを探す
        tryDirectAccess();
        
        // 4. WebGLシェーダーを直接操作
        setTimeout(() => {
          injectWebGLShader();
        }, 1000);
      }
      
      // 直接アクセスを試行
      function tryDirectAccess() {
        console.log("🔍 Trying direct access methods...");
        
        // Model-viewerの内部プロパティを直接確認
        console.log("ModelViewer properties:", Object.getOwnPropertyNames(modelViewer));
        
        // Symbolプロパティも確認
        const symbols = Object.getOwnPropertySymbols(modelViewer);
        console.log("ModelViewer symbols:", symbols);
        
        // 各Symbolプロパティを確認
        symbols.forEach((symbol, index) => {
          try {
            const value = modelViewer[symbol];
            console.log(`Symbol ${index} (${symbol.toString()}):`, typeof value, value);
            
            // Three.jsオブジェクトっぽいものを探す
            if (value && typeof value === 'object') {
              if (value.scene || value.model || (value.children && value.children.length > 0)) {
                console.log("Found potential scene in symbol property:", symbol.toString());
                processAnyObject(value, `Symbol[${symbol.toString()}]`);
              }
            }
          } catch (e) {
            console.log(`Cannot access symbol ${index}:`, e.message);
          }
        });
        
        // プロトタイプチェーンも確認
        let proto = Object.getPrototypeOf(modelViewer);
        let depth = 0;
        while (proto && depth < 5) {
          console.log(`Prototype ${depth}:`, proto.constructor.name);
          const protoProps = Object.getOwnPropertyNames(proto);
          protoProps.forEach(prop => {
            if (prop.includes('scene') || prop.includes('model') || prop.includes('three')) {
              console.log(`Found potential property in prototype: ${prop}`);
              try {
                const value = modelViewer[prop];
                if (value && typeof value === 'object') {
                  processAnyObject(value, prop);
                }
              } catch (e) {
                console.log(`Cannot access ${prop}:`, e.message);
              }
            }
          });
          proto = Object.getPrototypeOf(proto);
          depth++;
        }
      }
      
      // 任意のオブジェクトを処理
      function processAnyObject(obj, path) {
        console.log(`🔧 Processing object at ${path}:`, obj);
        
        if (!obj) return;
        
        // Three.jsオブジェクトかチェック
        if (obj.traverse && typeof obj.traverse === 'function') {
          console.log(`✓ Found traversable object at ${path}`);
          processThreeScene(obj, path);
          return;
        }
        
        // 子要素やプロパティを探す
        if (obj.scene && obj.scene.traverse) {
          console.log(`✓ Found scene at ${path}.scene`);
          processThreeScene(obj.scene, `${path}.scene`);
          return;
        }
        
        if (obj.model && obj.model.traverse) {
          console.log(`✓ Found model at ${path}.model`);
          processThreeScene(obj.model, `${path}.model`);
          return;
        }
        
        // 配列やオブジェクトの中も探す
        if (obj.children && Array.isArray(obj.children)) {
          obj.children.forEach((child, index) => {
            if (child && typeof child === 'object') {
              processAnyObject(child, `${path}.children[${index}]`);
            }
          });
        }
        
        // その他のプロパティも浅く探す
        for (let key in obj) {
          if (key !== 'children' && obj[key] && typeof obj[key] === 'object') {
            if (obj[key].traverse || obj[key].scene || obj[key].model) {
              processAnyObject(obj[key], `${path}.${key}`);
            }
          }
        }
      }
      
      // Three.jsシーンを処理
      function processThreeScene(scene, path) {
        console.log(`🎨 Processing Three.js scene at ${path}`);
        
        let meshCount = 0;
        
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`Processing mesh ${meshCount}: ${node.name || 'unnamed'}`);
            
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                // 両面表示
                material.side = 2; // THREE.DoubleSide
                
                // シェーダー修正
                material.onBeforeCompile = function(shader) {
                  console.log(`Modifying shader for material ${index}`);
                  
                  // フラグメントシェーダーに裏面色を追加
                  shader.fragmentShader = shader.fragmentShader.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                  );
                  
                  // 最終出力前に裏面チェック
                  shader.fragmentShader = shader.fragmentShader.replace(
                    /}\s*$/,
                    `
                    // 裏面の場合は黒に変更
                    if (!gl_FrontFacing) {
                      gl_FragColor = vec4(0.0, 0.0, 0.0, gl_FragColor.a);
                    }
                    }
                    `
                  );
                };
                
                material.needsUpdate = true;
                console.log(`✓ Material ${index} processed for backface coloring`);
              }
            });
          }
        });
        
        console.log(`🎉 Successfully processed ${meshCount} meshes in scene at ${path}`);
      }
      
      // WebGLシェーダーを直接操作
      function injectWebGLShader() {
        console.log("🎮 Attempting WebGL shader injection...");
        
        try {
          const canvas = modelViewer.shadowRoot?.querySelector('canvas');
          if (!canvas) {
            console.log("No canvas found for WebGL injection");
            return;
          }
          
          const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
          if (!gl) {
            console.log("No WebGL context found");
            return;
          }
          
          console.log("WebGL context acquired, attempting shader override...");
          
          // WebGLの関数をオーバーライド（実験的）
          const originalShaderSource = gl.shaderSource;
          gl.shaderSource = function(shader, source) {
            if (source.includes('gl_FragColor') && !source.includes('gl_FrontFacing')) {
              console.log("Modifying fragment shader...");
              source = source.replace(
                /gl_FragColor\s*=\s*([^;]+);/g,
                `
                if (gl_FrontFacing) {
                  gl_FragColor = $1;
                } else {
                  gl_FragColor = vec4(1.0, 0.0, 0.0, ($1).a);
                }
                `
              );
            }
            return originalShaderSource.call(this, shader, source);
          };
          
          console.log("✓ WebGL shader override installed");
          
        } catch (error) {
          console.error("WebGL shader injection failed:", error);
        }
      }
      
      // 裏面に色をつける関数
      async function addBackfaceColor() {
        console.log("Starting backface color application...");
        
        try {
          // model-viewerが完全に読み込まれるまで待機
          await modelViewer.updateComplete;
          
          if (!modelViewer.model) {
            console.log("Model not available yet, retrying...");
            setTimeout(() => addBackfaceColor(), 300);
            return;
          }
          
          const model = modelViewer.model;
          console.log("Model object:", model);
          console.log("Model constructor:", model.constructor.name);
          console.log("Model keys:", Object.keys(model));
          console.log("Model type:", model.type);
          
          // プロパティを詳細に調査
          for (let key in model) {
            if (model.hasOwnProperty(key)) {
              console.log(`model.${key}:`, typeof model[key], model[key]);
            }
          }
          
          // 可能性のあるシーンアクセス方法を全て試す
          let scene = null;
          
          // 方法1: 直接sceneプロパティ
          if (model.scene && typeof model.scene.traverse === 'function') {
            scene = model.scene;
            console.log("✓ Found scene via model.scene");
          }
          // 方法2: scenesプロパティ
          else if (model.scenes && model.scenes.length > 0 && typeof model.scenes[0].traverse === 'function') {
            scene = model.scenes[0];
            console.log("✓ Found scene via model.scenes[0]");
          }
          // 方法3: モデル自体がシーンの場合
          else if (model.children && typeof model.traverse === 'function') {
            scene = model;
            console.log("✓ Using model directly as scene");
          }
          // 方法4: nodeプロパティ
          else if (model.node && typeof model.node.traverse === 'function') {
            scene = model.node;
            console.log("✓ Found scene via model.node");
          }
          // 方法5: rootプロパティ
          else if (model.root && typeof model.root.traverse === 'function') {
            scene = model.root;
            console.log("✓ Found scene via model.root");
          }
          // 方法6: 他の可能性
          else {
            console.log("Checking all properties for traverse method...");
            for (let key in model) {
              if (model[key] && typeof model[key].traverse === 'function') {
                scene = model[key];
                console.log(`✓ Found scene via model.${key}`);
                break;
              }
            }
          }
          
          if (!scene) {
            console.error("❌ No traversable scene found in model");
            console.log("Attempting manual processing...");
            processNodeManually(model);
            return;
          }
          
          console.log("Scene object:", scene);
          console.log("Scene type:", scene.type);
          console.log("Scene children:", scene.children ? scene.children.length : 'none');
          
          let processedCount = 0;
          
          scene.traverse((node) => {
            if (node.isMesh && node.material) {
              processedCount++;
              console.log(`Processing mesh ${processedCount}:`, node.name || 'unnamed');
              
              const materials = Array.isArray(node.material) ? node.material : [node.material];
              
              materials.forEach((material, index) => {
                if (material) {
                  console.log(`Processing material ${index}:`, material.type);
                  
                  // 両面表示を有効にする
                  material.side = 2; // THREE.DoubleSide
                  
                  // カスタムシェーダーで裏面に色をつける
                  material.onBeforeCompile = function(shader) {
                    console.log("Compiling shader for material:", material.name || index);
                    
                    shader.fragmentShader = shader.fragmentShader.replace(
                      '#include <output_fragment>',
                      `
                      #include <output_fragment>
                      
                      if ( !gl_FrontFacing ) {
                        gl_FragColor = vec4( 1.0, 0.0, 0.0, gl_FragColor.a );
                      }
                      `
                    );
                  };
                  
                  material.needsUpdate = true;
                  console.log(`✓ Material ${index} processed`);
                }
              });
            }
          });
          
          console.log(`✅ Successfully processed ${processedCount} meshes`);
          
        } catch (error) {
          console.error("❌ Error in addBackfaceColor:", error);
        }
      }
      
      // 手動でノードを処理する関数
      function processNodeManually(node, depth = 0) {
        const indent = "  ".repeat(depth);
        console.log(`${indent}Processing node:`, node.constructor.name, node.type || 'unknown', node.name || 'unnamed');
        
        let processedCount = 0;
        
        // メッシュかどうかチェック
        if (node.isMesh && node.material) {
          processedCount++;
          console.log(`${indent}✓ Found mesh:`, node.name || 'unnamed');
          
          const materials = Array.isArray(node.material) ? node.material : [node.material];
          
          materials.forEach((material, index) => {
            if (material) {
              console.log(`${indent}  Processing material ${index}:`, material.type);
              
              // 両面表示を有効にする
              material.side = 2; // THREE.DoubleSide
              
              // カスタムシェーダーで裏面に色をつける
              material.onBeforeCompile = function(shader) {
                console.log(`${indent}  Compiling shader for material:`, material.name || index);
                
                shader.fragmentShader = shader.fragmentShader.replace(
                  '#include <output_fragment>',
                  `
                  #include <output_fragment>
                  
                  if ( !gl_FrontFacing ) {
                    gl_FragColor = vec4( 1.0, 0.0, 0.0, gl_FragColor.a );
                  }
                  `
                );
              };
              
              material.needsUpdate = true;
              console.log(`${indent}  ✓ Material ${index} processed`);
            }
          });
        }
        
        // 子ノードを再帰的に処理
        if (node.children && node.children.length > 0) {
          console.log(`${indent}Found ${node.children.length} children`);
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childProcessed = processNodeManually(child, depth + 1);
            processedCount += childProcessed;
          }
        }
        
        // オブジェクトの他のプロパティもチェック
        for (let key in node) {
          if (key !== 'children' && node[key] && typeof node[key] === 'object' && node[key].constructor && node[key].constructor.name) {
            if (node[key].isMesh || (node[key].children && node[key].children.length > 0)) {
              console.log(`${indent}Checking property ${key}:`, node[key].constructor.name);
              const propProcessed = processNodeManually(node[key], depth + 1);
              processedCount += propProcessed;
            }
          }
        }
        
        if (depth === 0) {
          console.log(`✅ Manual processing complete. Processed ${processedCount} meshes total.`);
        }
        
        return processedCount;
      }
      
      // 代替アプローチ：Three.jsレンダラーに直接アクセス
      function tryAlternativeApproach() {
        console.log("🔄 Trying alternative approach...");
        
        try {
          // Shadow DOMからcanvasを取得
          const shadowRoot = modelViewer.shadowRoot;
          if (!shadowRoot) {
            console.log("No shadow root found");
            return;
          }
          
          const canvas = shadowRoot.querySelector('canvas');
          if (!canvas) {
            console.log("No canvas found in shadow root");
            return;
          }
          
          console.log("Canvas found:", canvas);
          
          // WebGLレンダリングコンテキストを取得
          const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
          if (!gl) {
            console.log("No WebGL context found");
            return;
          }
          
          console.log("WebGL context found");
          
          // model-viewerの内部APIを使用（実験的）
          if (modelViewer.model && modelViewer.model.scene) {
            console.log("✓ Found scene via model.scene in alternative approach");
            processSceneAlternative(modelViewer.model.scene);
            return;
          }
          
          // より深いレベルでのアクセスを試行
          const allProperties = getAllProperties(modelViewer);
          console.log("All model-viewer properties:", allProperties);
          
          // Three.jsのシーンを探す
          for (let prop of allProperties) {
            try {
              const value = getNestedProperty(modelViewer, prop);
              if (value && typeof value.traverse === 'function') {
                console.log(`✓ Found traversable object at: ${prop}`);
                processSceneAlternative(value);
                break;
              }
            } catch (e) {
              // プロパティアクセスエラーは無視
            }
          }
          
        } catch (error) {
          console.error("Error in alternative approach:", error);
        }
      }
      
      // オブジェクトの全プロパティを再帰的に取得
      function getAllProperties(obj, prefix = '', depth = 0, maxDepth = 3) {
        const properties = [];
        if (depth > maxDepth) return properties;
        
        try {
          for (let key in obj) {
            const fullPath = prefix ? `${prefix}.${key}` : key;
            properties.push(fullPath);
            
            if (obj[key] && typeof obj[key] === 'object' && depth < maxDepth) {
              properties.push(...getAllProperties(obj[key], fullPath, depth + 1, maxDepth));
            }
          }
        } catch (e) {
          // プロパティアクセスエラーは無視
        }
        
        return properties;
      }
      
      // ネストしたプロパティを安全に取得
      function getNestedProperty(obj, path) {
        return path.split('.').reduce((current, key) => {
          return current && current[key] !== undefined ? current[key] : null;
        }, obj);
      }
      
      // 代替的なシーン処理
      function processSceneAlternative(scene) {
        console.log("🎯 Processing scene with alternative method");
        
        if (!scene || typeof scene.traverse !== 'function') {
          console.log("Invalid scene for alternative processing");
          return;
        }
        
        let meshCount = 0;
        
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`🔧 Alternative processing mesh ${meshCount}:`, node.name || 'unnamed');
            
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                // より強力なシェーダー置換
                material.side = 2; // DoubleSide
                
                const originalOnBeforeCompile = material.onBeforeCompile;
                material.onBeforeCompile = function(shader) {
                  if (originalOnBeforeCompile) {
                    originalOnBeforeCompile.call(this, shader);
                  }
                  
                  // より確実なシェーダー置換
                  if (shader.fragmentShader.includes('gl_FragColor')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /gl_FragColor\s*=\s*([^;]+);/g,
                      `
                      if (gl_FrontFacing) {
                        gl_FragColor = $1;
                      } else {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, ($1).a);
                      }
                      `
                    );
                  } else {
                    // outputColorを使用している場合
                    shader.fragmentShader = shader.fragmentShader.replace(
                      '#include <output_fragment>',
                      `
                      #include <output_fragment>
                      if (!gl_FrontFacing) {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, gl_FragColor.a);
                      }
                      `
                    );
                  }
                  
                  console.log(`🎨 Alternative shader compiled for material:`, material.name || index);
                };
                
                material.needsUpdate = true;
              }
            });
          }
        });
        
        console.log(`🎉 Alternative approach processed ${meshCount} meshes`);
      }

      // URLパラメータからモデルURLを取得
      function getModelUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("src");
      }

      // 初期化
      document.addEventListener("DOMContentLoaded", () => {
        updateBackgroundColor();

        // URLパラメータにモデルURLがあれば読み込み
        const modelUrl = getModelUrlFromParams();
        if (modelUrl) {
          console.log("Loading model from URL parameter:", modelUrl);
          loadSampleModel(modelUrl);
        } else {
          // default.glbが存在しない場合のフォールバック
          checkDefaultModel();
        }
      });

      // default.glbの存在チェック
      async function checkDefaultModel() {
        try {
          const response = await fetch('./default.glb', { method: 'HEAD' });
          if (response.ok) {
            // default.glbが存在する場合
            console.log("Loading default.glb");
            modelViewer.src = "./default.glb";
          } else {
            // default.glbが存在しない場合、Arweaveのモデルを使用
            console.log("default.glb not found, using fallback model");
            modelViewer.src = "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
          }
        } catch (error) {
          // ネットワークエラーまたはファイルが存在しない場合
          console.log("default.glb not accessible, using fallback model");
          modelViewer.src = "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
        }
      }

      // 外部クリックでコントロールパネルを閉じる
      document.addEventListener("click", (e) => {
        if (
          !lightControls.contains(e.target) &&
          !lightControlButton.contains(e.target)
        ) {
          if (showControls) {
            showControls = false;
            lightControls.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
