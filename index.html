<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2025 bon-soleil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project includes code from the following third-party libraries:

1. **lit (by Google LLC)**
   License: BSD 3-Clause

   Copyright 2017 Google LLC
   SPDX-License-Identifier: BSD-3-Clause

   https://github.com/lit/lit/blob/main/LICENSE

2. **Three.js**
   License: MIT License

   Copyright 2010-2024 Three.js Authors
   SPDX-License-Identifier: MIT


-->
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer</title>
    <script type="module" src="./model-viewer.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background-color: #000000;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background-color: #000000;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: #000000;
        --progress-bar-color: #007bff;
        --progress-mask: transparent;
        display: block;
        background-color: var(--poster-color);
      }

      /* ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ */
      .custom-progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .progress-text {
        font-size: 14px;
        color: #333;
        font-weight: 500;
      }

      .progress-bar-track {
        width: 200px;
        height: 6px;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
        width: 0%;
      }

      .progress-percent {
        font-size: 12px;
        color: #666;
        font-weight: 500;
      }

      @keyframes progressPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ */
      .light-control-button {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .light-control-button svg {
        width: 28px;
        height: 28px;
        fill: #333;
      }

      .light-control-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
      .light-controls {
        position: absolute;
        top: 15px;
        right: 65px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 100;
        min-width: 200px;
        display: none;
      }

      .control-group {
        margin-bottom: 12px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .preset-buttons {
        display: flex;
        gap: 5px;
        margin-top: 10px;
      }

      .preset-button {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preset-button:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }

      /* èƒŒæ™¯åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */
      .background-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .bg-button {
        width: 32px;
        height: 32px;
        border: 2px solid #ddd;
        border-radius: 50%;
        background: transparent;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .bg-button.active {
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
      }

      .bg-button:hover {
        border-color: #007bff;
        transform: scale(1.1);
      }

      .bg-black {
        background: #000;
      }

      .bg-white {
        background: #fff;
        border-color: #ccc;
      }

      .bg-white.active {
        border-color: #007bff;
      }

      /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ’ãƒ³ãƒˆ */
      .controls-hint {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .container:hover .controls-hint {
        opacity: 1;
      }

      .controls-hint p {
        margin: 0;
        opacity: 0.9;
      }

      /* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */
      .error-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 300px;
        padding: 40px 20px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-text {
        max-width: 400px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc3545;
        margin: 0 0 8px 0;
      }

      .error-message {
        font-size: 14px;
        color: #666;
        margin: 0 0 20px 0;
        line-height: 1.4;
      }

      .viewer-link {
        display: inline-block;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .viewer-link:hover {
        background-color: #0056b3;
        color: white;
        text-decoration: none;
      }

      /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
      @media (max-width: 768px) {
        .light-controls {
          right: 10px;
          top: 65px;
          min-width: 180px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- ãƒ¢ãƒ‡ãƒ«ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ -->
      <model-viewer
        id="modelViewer"
        alt="goodsun | bon-soleil"
        camera-controls
        loading="eager"
        reveal="auto"
        exposure="0.7"
        shadow-intensity="0.7"
        shadow-softness="0.3"
        style="--poster-color: #000000; background-color: #000000"
        camera-orbit="0deg 75deg 105%"
        field-of-view="30deg"
        min-camera-orbit="auto auto auto"
        max-camera-orbit="auto auto auto"
        min-field-of-view="10deg"
        max-field-of-view="45deg"
        autoplay
        animation-crossfade-duration="300ms"
      >
        <!-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’ç„¡åŠ¹åŒ– -->
        <div slot="progress-bar"></div>

        <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
        <div class="custom-progress-bar" id="customProgressBar">
          <div class="progress-text">Loading 3D Model...</div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
          <div class="progress-percent" id="progressPercent">0%</div>
        </div>
      </model-viewer>

      <!-- ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ -->
      <button
        class="light-control-button"
        id="lightControlButton"
        title="Light Controls"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
          />
        </svg>
      </button>

      <!-- ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
      <div class="light-controls" id="lightControls">
        <div class="control-group">
          <label class="control-label">
            Brightness: <span id="exposureValue">70</span>%
          </label>
          <input
            type="range"
            min="0.1"
            max="2.0"
            step="0.1"
            value="0.7"
            id="exposureSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">
            Shadow: <span id="shadowValue">70</span>%
          </label>
          <input
            type="range"
            min="0"
            max="2.0"
            step="0.1"
            value="0.7"
            id="shadowSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">Background</label>
          <div class="background-toggle">
            <button
              id="bgBlackBtn"
              class="bg-button bg-black active"
              title="Black background"
            >
              âš«
            </button>
            <button
              id="bgWhiteBtn"
              class="bg-button bg-white"
              title="White background"
            >
              âšª
            </button>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-button" onclick="setPreset(0.5, 0.3)">
            Dim
          </button>
          <button class="preset-button" onclick="setPreset(0.7, 0.7)">
            Normal
          </button>
          <button class="preset-button" onclick="setPreset(1.5, 1.2)">
            Bright
          </button>
        </div>
      </div>

      <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ’ãƒ³ãƒˆ -->
      <div class="controls-hint">
        <p>Drag to rotate â€¢ Scroll to zoom â€¢ Right-click to pan</p>
      </div>
    </div>

    <script>
      const modelViewer = document.getElementById("modelViewer");
      const lightControlButton = document.getElementById("lightControlButton");
      const lightControls = document.getElementById("lightControls");
      const customProgressBar = document.getElementById("customProgressBar");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPercent = document.getElementById("progressPercent");
      const exposureSlider = document.getElementById("exposureSlider");
      const shadowSlider = document.getElementById("shadowSlider");
      const exposureValue = document.getElementById("exposureValue");
      const shadowValue = document.getElementById("shadowValue");
      const bgBlackBtn = document.getElementById("bgBlackBtn");
      const bgWhiteBtn = document.getElementById("bgWhiteBtn");

      let showControls = false;
      let currentBackgroundColor = "black";

      // ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
      lightControlButton.addEventListener("click", () => {
        showControls = !showControls;
        lightControls.style.display = showControls ? "block" : "none";
      });

      // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†
      modelViewer.addEventListener("load", () => {
        console.log("Model loaded successfully");
        updateBackgroundColor();

        // è£é¢ã«è‰²ã‚’ã¤ã‘ã‚‹ - è¤‡æ•°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’é †æ¬¡è©¦è¡Œ
        setTimeout(() => {
          addBackfaceColorSimple();
        }, 500);
      });

      modelViewer.addEventListener("error", (event) => {
        console.error("ğŸš¨ Model loading error detected:", event.detail);
        console.error("ğŸš¨ Current model src:", modelViewer.src);
        console.error("ğŸš¨ Error event object:", event);
        
        customProgressBar.style.display = "none";

        // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
        let errorMsg = "Failed to load 3D model";
        if (event.detail) {
          if (event.detail.type === "loadfailure") {
            // sourceErrorã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            if (event.detail.sourceError) {
              const sourceError = event.detail.sourceError;
              console.error("ğŸš¨ Source error:", sourceError);
              
              // TypeError: Failed to fetchã¯CORSã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
              if (sourceError.message && sourceError.message.includes("Failed to fetch")) {
                errorMsg = "Network error or CORS policy blocked the request";
                console.error("ğŸš¨ CORS/Network error detected");
              } else if (
                sourceError.message &&
                sourceError.message.includes("Invalid typed array length")
              ) {
                errorMsg = "Model file is too large for browser memory";
              } else if (
                sourceError.message &&
                sourceError.message.includes("texture")
              ) {
                errorMsg = "Failed to load model textures";
              } else if (
                sourceError.message &&
                sourceError.message.includes("scene")
              ) {
                errorMsg = "Model file is corrupted or incompatible format";
              } else {
                errorMsg = `Model loading failed: ${sourceError.message || "Unknown error"}`;
              }
            } else {
              errorMsg = "Model file is corrupted or incompatible";
              console.error("ğŸš¨ Load failure detected without source error");
            }
          } else if (event.detail.sourceError) {
            const sourceError = event.detail.sourceError;
            console.error("ğŸš¨ Source error without loadfailure:", sourceError);
            errorMsg = `Model loading error: ${sourceError.message || "Unknown error"}`;
          }
        }

        console.error("ğŸš¨ Final error message:", errorMsg);
        console.error("ğŸš¨ Model URL:", modelViewer.src);
        showError(errorMsg, modelViewer.src);
      });

      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç›£è¦–ã‚’è¿½åŠ 
      let loadingTimeout;
      
      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        console.log(`ğŸ“Š Loading progress: ${(progress * 100).toFixed(1)}%`);

        progressBarFill.style.width = `${progress * 100}%`;
        progressPercent.textContent = `${Math.round(progress * 100)}%`;

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        clearTimeout(loadingTimeout);
        
        // é€²è¡ŒãŒæ­¢ã¾ã£ãŸå ´åˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ30ç§’ï¼‰
        loadingTimeout = setTimeout(() => {
          console.error("ğŸš¨ Loading timeout detected - no progress for 30 seconds");
          if (progress < 1.0) {
            console.error("ğŸš¨ Calling showError due to timeout");
            showError("Loading timed out - possible network or memory issue", modelViewer.src);
          }
        }, 30000);

        // 100%ã«ãªã£ãŸã‚‰å³åº§ã«éè¡¨ç¤º
        if (progress >= 1.0) {
          customProgressBar.style.display = "none";
          clearTimeout(loadingTimeout);
        } else {
          customProgressBar.style.display = "flex";
        }
      });


      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
      exposureSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.exposure = value;
        exposureValue.textContent = Math.round(value * 100);
      });

      shadowSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.shadowIntensity = value;
        shadowValue.textContent = Math.round(value * 100);
      });

      // èƒŒæ™¯è‰²å¤‰æ›´
      bgBlackBtn.addEventListener("click", () => {
        currentBackgroundColor = "black";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      bgWhiteBtn.addEventListener("click", () => {
        currentBackgroundColor = "white";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      function updateBackgroundButtons() {
        bgBlackBtn.classList.toggle(
          "active",
          currentBackgroundColor === "black"
        );
        bgWhiteBtn.classList.toggle(
          "active",
          currentBackgroundColor === "white"
        );
      }

      function updateBackgroundColor() {
        const bgColor =
          currentBackgroundColor === "black" ? "#000000" : "#ffffff";
        modelViewer.style.setProperty("--poster-color", bgColor);
        modelViewer.style.backgroundColor = bgColor;

        // Shadow rootã®canvasã«ã‚‚é©ç”¨
        setTimeout(() => {
          const shadowRoot = modelViewer.shadowRoot;
          if (shadowRoot) {
            const canvas = shadowRoot.querySelector("canvas");
            if (canvas) {
              canvas.style.backgroundColor = bgColor;
            }
          }
        }, 100);
      }

      // ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š
      function setPreset(exposure, shadow) {
        exposureSlider.value = exposure;
        shadowSlider.value = shadow;
        modelViewer.exposure = exposure;
        modelViewer.shadowIntensity = shadow;
        exposureValue.textContent = Math.round(exposure * 100);
        shadowValue.textContent = Math.round(shadow * 100);
      }

      // ã‚µãƒ³ãƒ—ãƒ«ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
      function loadSampleModel(url) {
        console.log("Loading model:", url);
        
        // URLã®æ¤œè¨¼
        if (!isValidModelUrl(url)) {
          showError("Invalid model URL or unsupported file format", url);
          return;
        }
        
        modelViewer.src = url;
        customProgressBar.style.display = "flex";
        clearError();
      }
      
      // ãƒ¢ãƒ‡ãƒ«URLã®æ¤œè¨¼
      function isValidModelUrl(url) {
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          
          // å¯¾å¿œã—ã¦ã„ã‚‹æ‹¡å¼µå­ã‚’ãƒã‚§ãƒƒã‚¯
          const validExtensions = ['.glb', '.gltf'];
          const hasValidExtension = validExtensions.some(ext => pathname.endsWith(ext));
          
          if (!hasValidExtension) {
            console.error("ğŸš¨ Invalid file extension. Supported formats: .glb, .gltf");
            return false;
          }
          
          // ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒã‚§ãƒƒã‚¯
          if (!['http:', 'https:'].includes(urlObj.protocol)) {
            console.error("ğŸš¨ Invalid protocol. Only HTTP/HTTPS is supported");
            return false;
          }
          
          return true;
        } catch (e) {
          console.error("ğŸš¨ Invalid URL:", e);
          return false;
        }
      }

      // ãƒ¡ãƒ¢ãƒªãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ã‚’ãƒã‚§ãƒƒã‚¯
      function checkMemoryAndStorage() {
        const issues = [];
        
        // åˆ©ç”¨å¯èƒ½ãƒ¡ãƒ¢ãƒªã®æ¨å®š
        if (navigator.deviceMemory && navigator.deviceMemory < 4) {
          issues.push('ãƒ‡ãƒã‚¤ã‚¹ãƒ¡ãƒ¢ãƒªãŒä¸è¶³ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™');
        }
        
        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ãƒã‚§ãƒƒã‚¯
        try {
          const testKey = 'storage_test_' + Date.now();
          const testData = 'x'.repeat(1024 * 1024); // 1MBã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
          localStorage.setItem(testKey, testData);
          localStorage.removeItem(testKey);
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            issues.push('ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å®¹é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
          }
        }
        
        // ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ï¼ˆChromeé™å®šï¼‰
        if (performance.memory) {
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          if (memoryRatio > 0.8) {
            issues.push('ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã™ãã¾ã™');
          }
        }
        
        return issues;
      }
      
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      function clearStorageAndReload() {
        try {
          // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
          localStorage.clear();
          
          // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
          sessionStorage.clear();
          
          // IndexedDBã‚‚ã‚¯ãƒªã‚¢ï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
          if ('indexedDB' in window) {
            indexedDB.databases().then(databases => {
              databases.forEach(db => {
                indexedDB.deleteDatabase(db.name);
              });
            }).catch(() => {
              console.log('IndexedDB clear failed (may not be supported)');
            });
          }
          
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥APIã‚¯ãƒªã‚¢ï¼ˆService Workerä½¿ç”¨æ™‚ï¼‰
          if ('caches' in window) {
            caches.keys().then(names => {
              names.forEach(name => {
                caches.delete(name);
              });
            });
          }
          
          console.log('Storage cleared successfully');
          
          // 2ç§’å¾Œã«ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          setTimeout(() => {
            window.location.reload(true);
          }, 2000);
          
          return true;
        } catch (error) {
          console.error('Storage clear failed:', error);
          return false;
        }
      }

      // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
      function showError(message, modelUrl) {
        const container = document.querySelector(".container");
        const isInWebView = detectWebView();
        const memoryIssues = checkMemoryAndStorage();
        
        // ãƒ¡ãƒ¢ãƒªãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å•é¡ŒãŒã‚ã‚‹å ´åˆã®ç‰¹åˆ¥å¯¾å¿œ
        let storageActions = '';
        if (memoryIssues.length > 0) {
          storageActions = `
            <div style="margin: 15px 0; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; border-radius: 4px;">
              <p style="font-size: 12px; color: #856404; margin: 0 0 8px 0;"><strong>æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ:</strong></p>
              ${memoryIssues.map(issue => `<p style="font-size: 11px; color: #856404; margin: 2px 0;">â€¢ ${issue}</p>`).join('')}
            </div>
            <button onclick="clearStorageAndReload()" class="viewer-link" style="background: #ffc107; color: #000; margin-bottom: 8px;">
              ğŸ—‘ï¸ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†èª­ã¿è¾¼ã¿
            </button>
          `;
        }
        
        // WebViewå†…ã‹ã©ã†ã‹ã«å¿œã˜ã¦ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’å¤‰æ›´
        let buttonContent = '';
        let helpMessage = '';
        
        if (isInWebView) {
          buttonContent = `
            <button onclick="openInDefaultBrowser('${modelUrl}')" class="viewer-link">
              ğŸ“‹ URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã
            </button>
          `;
          helpMessage = 'ã“ã®ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯3Dè¡¨ç¤ºã«åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ã„ã¦ãã ã•ã„ã€‚';
        } else {
          buttonContent = `
            <button onclick="window.location.reload()" class="viewer-link">
              ğŸ”„ ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
            </button>
          `;
          helpMessage = 'ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ¢ãƒªä¸è¶³ã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å•é¡ŒãŒåŸå› ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚';
        }
        
        container.innerHTML = `
                <div class="error-display">
                    <div class="error-icon">âš ï¸</div>
                    <div class="error-text">
                        <p class="error-title">3D Model Loading Error</p>
                        <p class="error-message">${message}</p>
                        <p class="error-message" style="font-size: 12px; color: #888; margin-top: 10px;">
                          ${helpMessage}
                        </p>
                        ${storageActions}
                        ${buttonContent}
                        ${!isInWebView ? `<button onclick="clearStorageAndReload()" class="viewer-link" style="background: #6c757d; margin-top: 5px;">
                          ğŸ  ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢å¾Œãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹
                        </button>` : ''}
                    </div>
                </div>
            `;
      }

      function clearError() {
        // ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦å®Ÿè£…ï¼‰
      }

      // WebViewç’°å¢ƒã®æ¤œå‡ºï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
      function detectWebView() {
        const userAgent = navigator.userAgent;
        
        // ä¸»è¦ãªWebViewãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿
        const webViewPatterns = [
          /wv/i,           // Android WebView
          /WebView/i,      // æ±ç”¨WebView
          /FBAN|FBAV/i,   // Facebookå†…ãƒ–ãƒ©ã‚¦ã‚¶
          /Line/i,         // LINEå†…ãƒ–ãƒ©ã‚¦ã‚¶
          /Instagram/i,    // Instagramå†…ãƒ–ãƒ©ã‚¦ã‚¶
          /Twitter/i       // Twitterå†…ãƒ–ãƒ©ã‚¦ã‚¶
        ];
        
        return webViewPatterns.some(pattern => pattern.test(userAgent));
      }

      // æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§URLã‚’é–‹ã
      function openInDefaultBrowser(modelUrl) {
        const currentUrl = window.location.href;
        const baseUrl = currentUrl.split('?')[0];
        const fullUrl = `${baseUrl}?src=${encodeURIComponent(modelUrl)}`;
        
        console.log('Attempting to open in default browser:', fullUrl);
        
        // ãƒ¢ãƒã‚¤ãƒ«ç’°å¢ƒã®åˆ¤å®š
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        // 1. Androidã®å ´åˆã€ã‚¤ãƒ³ãƒ†ãƒ³ãƒˆURLã‚’è©¦è¡Œ
        if (isAndroid) {
          const intentUrl = `intent://${fullUrl.replace(/^https?:\/\//, '')}#Intent;action=android.intent.action.VIEW;scheme=https;end`;
          window.location.href = intentUrl;
          
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: 3ç§’å¾Œã«ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼
          setTimeout(() => {
            copyToClipboardAndNotify(fullUrl);
          }, 3000);
          return;
        }
        
        // 2. iOSã®å ´åˆã€window.openã‚’è©¦è¡Œ
        if (isIOS) {
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ
            copyToClipboardAndNotify(fullUrl);
          }
          return;
        }
        
        // 3. ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã¾ãŸã¯ãã®ä»–ã®ç’°å¢ƒ
        try {
          // æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ã
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ
            copyToClipboardAndNotify(fullUrl);
          }
        } catch (e) {
          // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
          copyToClipboardAndNotify(fullUrl);
        }
      }

      // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
      function copyToClipboardAndNotify(url) {
        console.log('Copying to clipboard:', url);
        
        // è¤‡æ•°ã®æ–¹æ³•ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼ã‚’è©¦è¡Œ
        if (navigator.clipboard && navigator.clipboard.writeText) {
          // æœ€æ–°ã®Clipboard API
          navigator.clipboard.writeText(url).then(() => {
            console.log('Copied using Clipboard API');
            showCopySuccessAlert(url);
          }).catch(() => {
            console.log('Clipboard API failed, trying fallback');
            fallbackCopyToClipboard(url);
          });
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–¹æ³•
          fallbackCopyToClipboard(url);
        }
      }

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–¹æ³•ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
      function fallbackCopyToClipboard(url) {
        try {
          // æ–¹æ³•1: document.execCommandï¼ˆå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œï¼‰
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.select();
          textArea.setSelectionRange(0, 99999);
          
          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);
          
          if (successful) {
            console.log('Copied using execCommand');
            showCopySuccessAlert(url);
          } else {
            console.log('execCommand failed, showing prompt');
            showManualCopyPrompt(url);
          }
        } catch (error) {
          console.log('execCommand error:', error);
          showManualCopyPrompt(url);
        }
      }

      // ã‚³ãƒ”ãƒ¼æˆåŠŸæ™‚ã®ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
      function showCopySuccessAlert(url) {
        alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\næ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§è²¼ã‚Šä»˜ã‘ã¦é–‹ã„ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸURL:\n${url}`);
      }

      // æ‰‹å‹•ã‚³ãƒ”ãƒ¼ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
      function showManualCopyPrompt(url) {
        const userChoice = confirm(
          'è‡ªå‹•ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n' +
          'ä»¥ä¸‹ã®æ–¹æ³•ã§å¯¾å‡¦ã§ãã¾ã™ï¼š\n' +
          'â€¢ OK: URLã‚’è¡¨ç¤ºã—ã¦ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚³ãƒ”ãƒ¼\n' +
          'â€¢ ã‚­ãƒ£ãƒ³ã‚»ãƒ«: ãã®ã¾ã¾çµ‚äº†\n\n' +
          'URL: ' + url
        );
        
        if (userChoice) {
          // URLã‚’è¡¨ç¤ºã™ã‚‹ã ã‘ã§ã€å†è©¦è¡Œã¯ã—ãªã„
          alert(
            'URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ï¼š\n\n' + url + 
            '\n\nâ€»ã“ã®URLã‚’é¸æŠã—ã¦ã‚³ãƒ”ãƒ¼ï¼ˆCtrl+C / Cmd+Cï¼‰ã—ã¦ãã ã•ã„'
          );
        }
      }

      // ã‚·ãƒ³ãƒ—ãƒ«ãªè£é¢ã‚°ãƒ¬ãƒ¼ç€è‰²æ©Ÿèƒ½
      function addBackfaceColorSimple() {
        console.log("ğŸ¯ Starting backface gray coloring...");

        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å°‘ã—å¾…ã¤
        setTimeout(() => {
          console.log("Checking model availability...");
          console.log("modelViewer.model:", modelViewer.model);
          console.log("modelViewer properties:", Object.keys(modelViewer));
          
          // è¤‡æ•°ã®æ–¹æ³•ã§ãƒ¢ãƒ‡ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹
          let model = null;
          
          if (modelViewer.model) {
            model = modelViewer.model;
            console.log("âœ“ Found model via modelViewer.model");
          } else {
            // model-viewerã®å†…éƒ¨ã‚’æ¢ç´¢
            console.log("âš ï¸ modelViewer.model not available, searching alternatives...");
            
            // Shadow DOMã‹ã‚‰æ¢ã™
            const shadowRoot = modelViewer.shadowRoot;
            if (shadowRoot) {
              console.log("Found shadow root, searching for Three.js scene...");
              
              // å¯èƒ½æ€§ã®ã‚ã‚‹å†…éƒ¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ¢ã™
              for (let key in modelViewer) {
                try {
                  const value = modelViewer[key];
                  if (value && typeof value === 'object') {
                    console.log(`Checking modelViewer.${key}:`, typeof value, value?.constructor?.name);
                    
                    if (value.scene || value.model || (value.children && value.traverse)) {
                      model = value;
                      console.log(`âœ“ Found model via modelViewer.${key}`);
                      break;
                    }
                  }
                } catch (e) {
                  // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                }
              }
            }
          }
          
          if (model) {
            processModelForBackface(model);
          } else {
            console.log("âŒ No model found, retrying in 2 seconds...");
            setTimeout(() => addBackfaceColorSimple(), 2000);
          }
        }, 500);
      }

      // ãƒ¢ãƒ‡ãƒ«ã®è£é¢ã‚’ã‚°ãƒ¬ãƒ¼ã«ç€è‰²
      function processModelForBackface(model) {
        console.log("Processing model for backface gray coloring...");
        console.log("Model object:", model);
        console.log("Model properties:", Object.keys(model));
        console.log("Model constructor:", model.constructor.name);
        
        let scene = null;
        
        // ã‚ˆã‚Šè©³ç´°ã«ã‚·ãƒ¼ãƒ³ã‚’æ¢ã™
        if (model.scene && typeof model.scene.traverse === 'function') {
          scene = model.scene;
          console.log("âœ“ Found scene via model.scene");
        } else if (model.children && typeof model.traverse === 'function') {
          scene = model;
          console.log("âœ“ Using model directly as scene");
        } else {
          console.log("âš ï¸ Standard scene access failed, searching deeper...");
          
          // Symbolãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ¢ç´¢
          const symbols = Object.getOwnPropertySymbols(model);
          console.log(`Found ${symbols.length} symbol properties:`, symbols.map(s => s.toString()));
          
          for (let symbol of symbols) {
            try {
              const value = model[symbol];
              console.log(`Checking model[${symbol.toString()}]:`, typeof value, value?.constructor?.name);
              
              if (value && typeof value === 'object' && value.traverse && typeof value.traverse === 'function') {
                scene = value;
                console.log(`âœ“ Found scene via model[${symbol.toString()}]`);
                break;
              }
              
              // é…åˆ—ã®å ´åˆã€å„è¦ç´ ã‚’ãƒã‚§ãƒƒã‚¯
              if (Array.isArray(value)) {
                console.log(`  Array with ${value.length} elements`);
                for (let i = 0; i < value.length; i++) {
                  const element = value[i];
                  console.log(`    Element [${i}]:`, typeof element, element?.constructor?.name);
                  
                  if (element && typeof element === 'object') {
                    // è¦ç´ ã®è©³ç´°ã‚’è¡¨ç¤º
                    console.log(`    Element [${i}] keys:`, Object.keys(element));
                    console.log(`    Element [${i}] symbols:`, Object.getOwnPropertySymbols(element).map(s => s.toString()));
                    
                    // traverseãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‹ç¢ºèª
                    if (element.traverse && typeof element.traverse === 'function') {
                      scene = element;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}]`);
                      break;
                    }
                    
                    // Three.jsã®ã‚·ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã™
                    if (element.scene && element.scene.traverse) {
                      scene = element.scene;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}].scene`);
                      break;
                    }
                    
                    // ä¸€èˆ¬çš„ãªThree.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯
                    const threeJsProps = ['children', 'parent', 'geometry', 'material', 'matrix', 'position', 'rotation', 'scale'];
                    for (let prop of threeJsProps) {
                      if (element[prop] !== undefined) {
                        console.log(`    Element [${i}] has Three.js property: ${prop}`);
                        
                        // childrenãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚Šã€traverseãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚ã‚‹å ´åˆ
                        if (prop === 'children' && element.traverse && typeof element.traverse === 'function') {
                          scene = element;
                          console.log(`âœ“ Found Three.js object with traverse via model[${symbol.toString()}][${i}]`);
                          break;
                        }
                      }
                    }
                    if (scene) break;
                    
                    // è¦ç´ ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚å†å¸°çš„ã«æ¢ã™
                    for (let key in element) {
                      try {
                        const nestedValue = element[key];
                        if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                          scene = nestedValue;
                          console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}].${key}`);
                          break;
                        }
                      } catch (e) {
                        // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                      }
                    }
                    if (scene) break;
                  }
                }
                if (scene) break;
              }
              
              // ãƒã‚¹ãƒˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ¢ã™
              if (value && typeof value === 'object') {
                // é€šå¸¸ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                for (let nestedKey in value) {
                  try {
                    const nestedValue = value[nestedKey];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}].${nestedKey}`);
                      break;
                    }
                  } catch (e) {
                    // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                  }
                }
                if (scene) break;
                
                // Symbolãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚æ¢ã™
                const nestedSymbols = Object.getOwnPropertySymbols(value);
                for (let nestedSymbol of nestedSymbols) {
                  try {
                    const nestedValue = value[nestedSymbol];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${nestedSymbol.toString()}]`);
                      break;
                    }
                  } catch (e) {
                    // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                  }
                }
                if (scene) break;
              }
            } catch (e) {
              console.log(`Cannot access model[${symbol.toString()}]:`, e.message);
            }
          }
          
          if (!scene) {
            console.log("âŒ No traversable scene found after symbol search");
            return;
          }
        }

        let meshCount = 0;
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`Processing mesh ${meshCount}: ${node.name || 'unnamed'}`);

            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                console.log(`  Modifying material ${index}: ${material.type}`);
                
                // å…ƒã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä¿å­˜
                const originalSide = material.side;
                const originalOnBeforeCompile = material.onBeforeCompile;
                
                // ä¸¡é¢è¡¨ç¤ºã‚’å¼·åˆ¶çš„ã«æœ‰åŠ¹åŒ–
                material.side = 2; // THREE.DoubleSide
                
                // é€æ˜åº¦ã¨ã‚«ãƒªãƒ³ã‚°è¨­å®š
                if (material.transparent === undefined) {
                  material.transparent = false;
                }
                
                // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ä¿®æ­£ã§è£é¢ã‚’ã‚°ãƒ¬ãƒ¼ã«ï¼ˆç¢ºå®Ÿç‰ˆï¼‰
                material.onBeforeCompile = function (shader) {
                  console.log(`  Compiling shader for material ${index}`);
                  console.log(`  Original fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // å…ƒã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚‚å®Ÿè¡Œ
                  if (originalOnBeforeCompile && typeof originalOnBeforeCompile === 'function') {
                    originalOnBeforeCompile.call(this, shader);
                  }
                  
                  // ç¢ºå®Ÿã«gl_FrontFacingãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
                  const backfaceCode = `
                    // è£é¢ãƒ€ãƒ¼ã‚¯ã‚°ãƒ¬ãƒ¼ç€è‰²
                    if (!gl_FrontFacing) {
                      gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
                    }
                  `;
                  
                  // è¤‡æ•°ã®æŒ¿å…¥ãƒã‚¤ãƒ³ãƒˆã‚’è©¦è¡Œ
                  let modified = false;
                  
                  // 1. output_fragment ã®å¾Œ
                  if (shader.fragmentShader.includes('#include <output_fragment>')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /#include <output_fragment>/g,
                      `#include <output_fragment>\n${backfaceCode}`
                    );
                    modified = true;
                    console.log(`  âœ“ Applied after output_fragment`);
                  }
                  
                  // 2. mainé–¢æ•°ã®æœ€å¾Œ
                  if (!modified && shader.fragmentShader.includes('void main()')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /(void\s+main\s*\(\s*\)\s*{[\s\S]*?)(\s*}\s*)$/,
                      `$1${backfaceCode}$2`
                    );
                    modified = true;
                    console.log(`  âœ“ Applied at end of main()`);
                  }
                  
                  // 3. æœ€çµ‚æ‰‹æ®µï¼šã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®æœ€å¾Œ
                  if (!modified) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /}\s*$/,
                      `${backfaceCode}\n}`
                    );
                    console.log(`  âœ“ Applied at shader end (forced)`);
                  }
                  
                  console.log(`  Modified fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šä¿®æ­£ã•ã‚ŒãŸã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ä¸€éƒ¨ã‚’è¡¨ç¤º
                  const lines = shader.fragmentShader.split('\n');
                  console.log(`  Last 5 lines of shader:`, lines.slice(-5));
                };
                
                material.needsUpdate = true;
                console.log(`  âœ“ Material ${index} processed for gray backface (enhanced)`);
              }
            });
          }
        });

        console.log(`âœ… Processed ${meshCount} meshes with gray backface coloring`);
      }

      // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«URLã‚’å–å¾—
      function getModelUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("src");
      }

      // ãƒ–ãƒ©ã‚¦ã‚¶ã®è‡ªå‹•ãƒªãƒ­ãƒ¼ãƒ‰ã‚’é˜²æ­¢
      window.addEventListener('beforeunload', (event) => {
        console.log("ğŸš¨ Page unload detected - checking if intentional...");
        
        // ãƒ¡ãƒ¢ãƒªä¸è¶³ãªã©ã§ã®æ„å›³ã—ãªã„ãƒªãƒ­ãƒ¼ãƒ‰ã‚’æ¤œå‡º
        if (performance.memory) {
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          if (memoryRatio > 0.9) {
            console.error("ğŸš¨ High memory usage detected during unload:", memoryRatio);
            // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰å†èª­ã¿è¾¼ã¿
            localStorage.clear();
            sessionStorage.clear();
          }
        }
      });

      // ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•ãƒªãƒ­ãƒ¼ãƒ‰ã‚’é˜²æ­¢
      window.addEventListener('error', (event) => {
        console.error("ğŸš¨ Global error detected:", event.error);
        if (event.error && event.error.message) {
          if (event.error.message.includes('memory') || 
              event.error.message.includes('quota') ||
              event.error.message.includes('storage')) {
            console.error("ğŸš¨ Memory/Storage error - preventing automatic reload");
            event.preventDefault();
            showError("Memory or storage error detected", modelViewer.src || "unknown");
          }
        }
      });

      // åˆæœŸåŒ–
      document.addEventListener("DOMContentLoaded", () => {
        console.log("ğŸš€ Page loaded, initializing...");
        updateBackgroundColor();

        // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ãƒ¢ãƒ‡ãƒ«URLãŒã‚ã‚Œã°èª­ã¿è¾¼ã¿
        const modelUrl = getModelUrlFromParams();
        if (modelUrl) {
          console.log("ğŸ“¥ Loading model from URL parameter:", modelUrl);
          loadSampleModel(modelUrl);
        } else {
          console.log("ğŸ” No URL parameter, checking default model...");
          // default.glbãŒå­˜åœ¨ã—ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          checkDefaultModel();
        }
        
        // 5åˆ†å¾Œã«å¼·åˆ¶çš„ã«ã‚¨ãƒ©ãƒ¼ç”»é¢ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        setTimeout(() => {
          if (!modelViewer.model && customProgressBar.style.display !== "none") {
            console.error("ğŸš¨ Force timeout after 5 minutes");
            showError("Loading took too long - please try again", modelViewer.src || "unknown");
          }
        }, 300000);
      });

      // default.glbã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
      async function checkDefaultModel() {
        try {
          const response = await fetch("./default.glb", { method: "HEAD" });
          if (response.ok) {
            // default.glbãŒå­˜åœ¨ã™ã‚‹å ´åˆ
            console.log("Loading default.glb");
            modelViewer.src = "./default.glb";
          } else {
            // default.glbãŒå­˜åœ¨ã—ãªã„å ´åˆã€Arweaveã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
            console.log("default.glb not found, using fallback model");
            modelViewer.src =
              "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
          }
        } catch (error) {
          // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆ
          console.log("default.glb not accessible, using fallback model");
          modelViewer.src =
            "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
        }
      }

      // å¤–éƒ¨ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
      document.addEventListener("click", (e) => {
        if (
          !lightControls.contains(e.target) &&
          !lightControlButton.contains(e.target)
        ) {
          if (showControls) {
            showControls = false;
            lightControls.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
