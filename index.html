<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2025 bon-soleil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project includes code from the following third-party libraries:

1. **lit (by Google LLC)**
   License: BSD 3-Clause

   Copyright 2017 Google LLC  
   SPDX-License-Identifier: BSD-3-Clause

   https://github.com/lit/lit/blob/main/LICENSE

2. **Three.js**
   License: MIT License

   Copyright 2010-2024 Three.js Authors  
   SPDX-License-Identifier: MIT


-->
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer</title>
    <script type="module" src="./model-viewer.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background-color: #000000;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background-color: #000000;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: #000000;
        --progress-bar-color: #007bff;
        --progress-mask: transparent;
        display: block;
        background-color: var(--poster-color);
      }

      /* „Ç´„Çπ„Çø„É†„Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº */
      .custom-progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .progress-text {
        font-size: 14px;
        color: #333;
        font-weight: 500;
      }

      .progress-bar-track {
        width: 200px;
        height: 6px;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
        width: 0%;
      }

      .progress-percent {
        font-size: 12px;
        color: #666;
        font-weight: 500;
      }

      @keyframes progressPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* „É©„Ç§„Éà„Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥ */
      .light-control-button {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .light-control-button svg {
        width: 28px;
        height: 28px;
        fill: #333;
      }

      .light-control-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* „É©„Ç§„Éà„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ */
      .light-controls {
        position: absolute;
        top: 15px;
        right: 65px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 100;
        min-width: 200px;
        display: none;
      }

      .control-group {
        margin-bottom: 12px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .preset-buttons {
        display: flex;
        gap: 5px;
        margin-top: 10px;
      }

      .preset-button {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preset-button:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }

      /* ËÉåÊôØÂàá„ÇäÊõø„Åà„Éú„Çø„É≥ */
      .background-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .bg-button {
        width: 32px;
        height: 32px;
        border: 2px solid #ddd;
        border-radius: 50%;
        background: transparent;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .bg-button.active {
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
      }

      .bg-button:hover {
        border-color: #007bff;
        transform: scale(1.1);
      }

      .bg-black {
        background: #000;
      }

      .bg-white {
        background: #fff;
        border-color: #ccc;
      }

      .bg-white.active {
        border-color: #007bff;
      }

      /* „Ç≥„É≥„Éà„É≠„Éº„É´„Éí„É≥„Éà */
      .controls-hint {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .container:hover .controls-hint {
        opacity: 1;
      }

      .controls-hint p {
        margin: 0;
        opacity: 0.9;
      }

      /* „Ç®„É©„ÉºË°®Á§∫ */
      .error-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 300px;
        padding: 40px 20px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-text {
        max-width: 400px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc3545;
        margin: 0 0 8px 0;
      }

      .error-message {
        font-size: 14px;
        color: #666;
        margin: 0 0 20px 0;
        line-height: 1.4;
      }

      .viewer-link {
        display: inline-block;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        transition: background-color 0.2s;
      }

      .viewer-link:hover {
        background-color: #0056b3;
        color: white;
        text-decoration: none;
      }

      /* „É¢„Éê„Ç§„É´ÂØæÂøú */
      @media (max-width: 768px) {
        .light-controls {
          right: 10px;
          top: 65px;
          min-width: 180px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- „É¢„Éá„É´„Éì„É•„Éº„Ç¢„Éº -->
      <model-viewer
        id="modelViewer"
        alt="goodsun | bon-soleil"
        camera-controls
        loading="eager"
        reveal="auto"
        exposure="0.7"
        shadow-intensity="0.7"
        shadow-softness="0.3"
        style="--poster-color: #000000; background-color: #000000"
        camera-orbit="0deg 75deg 105%"
        field-of-view="30deg"
        min-camera-orbit="auto auto auto"
        max-camera-orbit="auto auto auto"
        min-field-of-view="10deg"
        max-field-of-view="45deg"
        autoplay
        animation-crossfade-duration="300ms"
      >
        <!-- „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÇíÁÑ°ÂäπÂåñ -->
        <div slot="progress-bar"></div>

        <!-- „Ç´„Çπ„Çø„É†„Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº -->
        <div class="custom-progress-bar" id="customProgressBar">
          <div class="progress-text">Loading 3D Model...</div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
          <div class="progress-percent" id="progressPercent">0%</div>
        </div>
      </model-viewer>

      <!-- „É©„Ç§„Éà„Ç≥„É≥„Éà„É≠„Éº„É´„Éú„Çø„É≥ -->
      <button
        class="light-control-button"
        id="lightControlButton"
        title="Light Controls"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
          />
        </svg>
      </button>

      <!-- „É©„Ç§„Éà„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´ -->
      <div class="light-controls" id="lightControls">
        <div class="control-group">
          <label class="control-label">
            Brightness: <span id="exposureValue">70</span>%
          </label>
          <input
            type="range"
            min="0.1"
            max="2.0"
            step="0.1"
            value="0.7"
            id="exposureSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">
            Shadow: <span id="shadowValue">70</span>%
          </label>
          <input
            type="range"
            min="0"
            max="2.0"
            step="0.1"
            value="0.7"
            id="shadowSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">Background</label>
          <div class="background-toggle">
            <button
              id="bgBlackBtn"
              class="bg-button bg-black active"
              title="Black background"
            >
              ‚ö´
            </button>
            <button
              id="bgWhiteBtn"
              class="bg-button bg-white"
              title="White background"
            >
              ‚ö™
            </button>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-button" onclick="setPreset(0.5, 0.3)">
            Dim
          </button>
          <button class="preset-button" onclick="setPreset(0.7, 0.7)">
            Normal
          </button>
          <button class="preset-button" onclick="setPreset(1.5, 1.2)">
            Bright
          </button>
        </div>
      </div>

      <!-- „Ç≥„É≥„Éà„É≠„Éº„É´„Éí„É≥„Éà -->
      <div class="controls-hint">
        <p>Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-click to pan</p>
      </div>
    </div>

    <script>
      const modelViewer = document.getElementById("modelViewer");
      const lightControlButton = document.getElementById("lightControlButton");
      const lightControls = document.getElementById("lightControls");
      const customProgressBar = document.getElementById("customProgressBar");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPercent = document.getElementById("progressPercent");
      const exposureSlider = document.getElementById("exposureSlider");
      const shadowSlider = document.getElementById("shadowSlider");
      const exposureValue = document.getElementById("exposureValue");
      const shadowValue = document.getElementById("shadowValue");
      const bgBlackBtn = document.getElementById("bgBlackBtn");
      const bgWhiteBtn = document.getElementById("bgWhiteBtn");

      let showControls = false;
      let currentBackgroundColor = "black";

      // „É©„Ç§„Éà„Ç≥„É≥„Éà„É≠„Éº„É´„ÅÆË°®Á§∫/ÈùûË°®Á§∫
      lightControlButton.addEventListener("click", () => {
        showControls = !showControls;
        lightControls.style.display = showControls ? "block" : "none";
      });

      // „É¢„Éá„É´Ë™≠„ÅøËæº„ÅøÂÆå‰∫Ü
      modelViewer.addEventListener("load", () => {
        console.log("Model loaded successfully");
        updateBackgroundColor();
        
        // Ë£èÈù¢„Å´Ëâ≤„Çí„Å§„Åë„Çã - Ë§áÊï∞„ÅÆ„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÈ†ÜÊ¨°Ë©¶Ë°å
        setTimeout(() => {
          addBackfaceColorSimple();
        }, 500);
      });

      modelViewer.addEventListener("error", (event) => {
        console.error("Model loading error:", event.detail);
        customProgressBar.style.display = "none";

        // „Ç®„É©„ÉºË°®Á§∫
        let errorMsg = "Failed to load 3D model";
        if (event.detail) {
          if (event.detail.type === "loadfailure") {
            errorMsg = "Model file is corrupted or incompatible";
          } else if (event.detail.sourceError) {
            const sourceError = event.detail.sourceError;
            if (
              sourceError.message &&
              sourceError.message.includes("Invalid typed array length")
            ) {
              errorMsg = "Model file is too large for browser memory";
            } else if (
              sourceError.message &&
              sourceError.message.includes("texture")
            ) {
              errorMsg = "Failed to load model textures";
            }
          }
        }

        showError(errorMsg, modelViewer.src);
      });

      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        console.log(`Loading progress: ${(progress * 100).toFixed(1)}%`);

        progressBarFill.style.width = `${progress * 100}%`;
        progressPercent.textContent = `${Math.round(progress * 100)}%`;

        // 100%„Å´„Å™„Å£„Åü„ÇâÂç≥Â∫ß„Å´ÈùûË°®Á§∫
        if (progress >= 1.0) {
          customProgressBar.style.display = "none";
        } else {
          customProgressBar.style.display = "flex";
        }
      });

      // „Çπ„É©„Ç§„ÉÄ„Éº„Ç§„Éô„É≥„Éà
      exposureSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.exposure = value;
        exposureValue.textContent = Math.round(value * 100);
      });

      shadowSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.shadowIntensity = value;
        shadowValue.textContent = Math.round(value * 100);
      });

      // ËÉåÊôØËâ≤Â§âÊõ¥
      bgBlackBtn.addEventListener("click", () => {
        currentBackgroundColor = "black";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      bgWhiteBtn.addEventListener("click", () => {
        currentBackgroundColor = "white";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      function updateBackgroundButtons() {
        bgBlackBtn.classList.toggle(
          "active",
          currentBackgroundColor === "black"
        );
        bgWhiteBtn.classList.toggle(
          "active",
          currentBackgroundColor === "white"
        );
      }

      function updateBackgroundColor() {
        const bgColor =
          currentBackgroundColor === "black" ? "#000000" : "#ffffff";
        modelViewer.style.setProperty("--poster-color", bgColor);
        modelViewer.style.backgroundColor = bgColor;

        // Shadow root„ÅÆcanvas„Å´„ÇÇÈÅ©Áî®
        setTimeout(() => {
          const shadowRoot = modelViewer.shadowRoot;
          if (shadowRoot) {
            const canvas = shadowRoot.querySelector("canvas");
            if (canvas) {
              canvas.style.backgroundColor = bgColor;
            }
          }
        }, 100);
      }

      // „Éó„É™„Çª„ÉÉ„ÉàË®≠ÂÆö
      function setPreset(exposure, shadow) {
        exposureSlider.value = exposure;
        shadowSlider.value = shadow;
        modelViewer.exposure = exposure;
        modelViewer.shadowIntensity = shadow;
        exposureValue.textContent = Math.round(exposure * 100);
        shadowValue.textContent = Math.round(shadow * 100);
      }

      // „Çµ„É≥„Éó„É´„É¢„Éá„É´Ë™≠„ÅøËæº„Åø
      function loadSampleModel(url) {
        console.log("Loading model:", url);
        modelViewer.src = url;
        customProgressBar.style.display = "flex";
        clearError();
      }

      // „Ç®„É©„ÉºË°®Á§∫
      function showError(message, modelUrl) {
        const container = document.querySelector(".container");
        const viewerUrl = `/index.html?src=${encodeURIComponent(
          modelUrl
        )}`;
        container.innerHTML = `
                <div class="error-display">
                    <div class="error-icon">‚ö†Ô∏è</div>
                    <div class="error-text">
                        <p class="error-title">3D Model Error</p>
                        <p class="error-message">${message}</p>
                        <a href="${viewerUrl}" target="_blank" rel="noopener noreferrer" class="viewer-link">
                            Display Standalone Viewer
                        </a>
                    </div>
                </div>
            `;
      }

      function clearError() {
        // „Ç®„É©„ÉºË°®Á§∫„Çí„ÇØ„É™„Ç¢ÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶ÂÆüË£ÖÔºâ
      }
      
      // „Ç∑„É≥„Éó„É´„Å™„Ç¢„Éó„É≠„Éº„ÉÅ„ÅßË£èÈù¢„Å´Ëâ≤„Çí„Å§„Åë„Çã
      function addBackfaceColorSimple() {
        console.log("üéØ Starting simple backface color approach...");
        
        // CSS/WebGL„Åß„ÅÆ„Ç∞„É≠„Éº„Éê„É´„Ç¢„Éó„É≠„Éº„ÉÅ
        try {
          // 1. CSS„Åß„ÅÆ„Ç¢„Éó„É≠„Éº„ÉÅÔºàÂà∂Èôê„ÅØ„ÅÇ„Çã„ÅåË©¶„Åó„Å¶„Åø„ÇãÔºâ
          const style = document.createElement('style');
          style.textContent = `
            model-viewer {
              --model-viewer-backface-color: #ff0000;
            }
          `;
          document.head.appendChild(style);
          console.log("‚úì CSS backface style added");
          
        } catch (error) {
          console.log("CSS approach failed:", error);
        }
        
        // 2. model-viewer„ÅÆ„Ç§„Éô„É≥„Éà„Å®API„Çí‰ΩøÁî®
        modelViewer.addEventListener('model-visibility', () => {
          console.log("Model visibility changed, trying direct access...");
          tryDirectAccess();
        });
        
        // 3. Âº∑Âà∂ÁöÑ„Å´„Ç∑„Éº„É≥„ÇíÊé¢„Åô
        tryDirectAccess();
        
        // 4. WebGL„Ç∑„Çß„Éº„ÉÄ„Éº„ÇíÁõ¥Êé•Êìç‰Ωú
        setTimeout(() => {
          injectWebGLShader();
        }, 1000);
      }
      
      // Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ„ÇíË©¶Ë°å
      function tryDirectAccess() {
        console.log("üîç Trying direct access methods...");
        
        // Model-viewer„ÅÆÂÜÖÈÉ®„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÁõ¥Êé•Á¢∫Ë™ç
        console.log("ModelViewer properties:", Object.getOwnPropertyNames(modelViewer));
        
        // Symbol„Éó„É≠„Éë„ÉÜ„Ç£„ÇÇÁ¢∫Ë™ç
        const symbols = Object.getOwnPropertySymbols(modelViewer);
        console.log("ModelViewer symbols:", symbols);
        
        // ÂêÑSymbol„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÁ¢∫Ë™ç
        symbols.forEach((symbol, index) => {
          try {
            const value = modelViewer[symbol];
            console.log(`Symbol ${index} (${symbol.toString()}):`, typeof value, value);
            
            // Three.js„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å£„ÅΩ„ÅÑ„ÇÇ„ÅÆ„ÇíÊé¢„Åô
            if (value && typeof value === 'object') {
              if (value.scene || value.model || (value.children && value.children.length > 0)) {
                console.log("Found potential scene in symbol property:", symbol.toString());
                processAnyObject(value, `Symbol[${symbol.toString()}]`);
              }
            }
          } catch (e) {
            console.log(`Cannot access symbol ${index}:`, e.message);
          }
        });
        
        // „Éó„É≠„Éà„Çø„Ç§„Éó„ÉÅ„Çß„Éº„É≥„ÇÇÁ¢∫Ë™ç
        let proto = Object.getPrototypeOf(modelViewer);
        let depth = 0;
        while (proto && depth < 5) {
          console.log(`Prototype ${depth}:`, proto.constructor.name);
          const protoProps = Object.getOwnPropertyNames(proto);
          protoProps.forEach(prop => {
            if (prop.includes('scene') || prop.includes('model') || prop.includes('three')) {
              console.log(`Found potential property in prototype: ${prop}`);
              try {
                const value = modelViewer[prop];
                if (value && typeof value === 'object') {
                  processAnyObject(value, prop);
                }
              } catch (e) {
                console.log(`Cannot access ${prop}:`, e.message);
              }
            }
          });
          proto = Object.getPrototypeOf(proto);
          depth++;
        }
      }
      
      // ‰ªªÊÑè„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂá¶ÁêÜ
      function processAnyObject(obj, path) {
        console.log(`üîß Processing object at ${path}:`, obj);
        
        if (!obj) return;
        
        // Three.js„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if (obj.traverse && typeof obj.traverse === 'function') {
          console.log(`‚úì Found traversable object at ${path}`);
          processThreeScene(obj, path);
          return;
        }
        
        // Â≠êË¶ÅÁ¥†„ÇÑ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÊé¢„Åô
        if (obj.scene && obj.scene.traverse) {
          console.log(`‚úì Found scene at ${path}.scene`);
          processThreeScene(obj.scene, `${path}.scene`);
          return;
        }
        
        if (obj.model && obj.model.traverse) {
          console.log(`‚úì Found model at ${path}.model`);
          processThreeScene(obj.model, `${path}.model`);
          return;
        }
        
        // ÈÖçÂàó„ÇÑ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰∏≠„ÇÇÊé¢„Åô
        if (obj.children && Array.isArray(obj.children)) {
          obj.children.forEach((child, index) => {
            if (child && typeof child === 'object') {
              processAnyObject(child, `${path}.children[${index}]`);
            }
          });
        }
        
        // „Åù„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇÇÊµÖ„ÅèÊé¢„Åô
        for (let key in obj) {
          if (key !== 'children' && obj[key] && typeof obj[key] === 'object') {
            if (obj[key].traverse || obj[key].scene || obj[key].model) {
              processAnyObject(obj[key], `${path}.${key}`);
            }
          }
        }
      }
      
      // Three.js„Ç∑„Éº„É≥„ÇíÂá¶ÁêÜ
      function processThreeScene(scene, path) {
        console.log(`üé® Processing Three.js scene at ${path}`);
        
        let meshCount = 0;
        
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`Processing mesh ${meshCount}: ${node.name || 'unnamed'}`);
            
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                // ‰∏°Èù¢Ë°®Á§∫
                material.side = 2; // THREE.DoubleSide
                
                // „Ç∑„Çß„Éº„ÉÄ„Éº‰øÆÊ≠£
                material.onBeforeCompile = function(shader) {
                  console.log(`Modifying shader for material ${index}`);
                  
                  // „Éï„É©„Ç∞„É°„É≥„Éà„Ç∑„Çß„Éº„ÉÄ„Éº„Å´Ë£èÈù¢Ëâ≤„ÇíËøΩÂä†
                  shader.fragmentShader = shader.fragmentShader.replace(
                    'void main() {',
                    `
                    void main() {
                    `
                  );
                  
                  // ÊúÄÁµÇÂá∫ÂäõÂâç„Å´Ë£èÈù¢„ÉÅ„Çß„ÉÉ„ÇØ
                  shader.fragmentShader = shader.fragmentShader.replace(
                    /}\s*$/,
                    `
                    // Ë£èÈù¢„ÅÆÂ†¥Âêà„ÅØÈªí„Å´Â§âÊõ¥
                    if (!gl_FrontFacing) {
                      gl_FragColor = vec4(0.0, 0.0, 0.0, gl_FragColor.a);
                    }
                    }
                    `
                  );
                };
                
                material.needsUpdate = true;
                console.log(`‚úì Material ${index} processed for backface coloring`);
              }
            });
          }
        });
        
        console.log(`üéâ Successfully processed ${meshCount} meshes in scene at ${path}`);
      }
      
      // WebGL„Ç∑„Çß„Éº„ÉÄ„Éº„ÇíÁõ¥Êé•Êìç‰Ωú
      function injectWebGLShader() {
        console.log("üéÆ Attempting WebGL shader injection...");
        
        try {
          const canvas = modelViewer.shadowRoot?.querySelector('canvas');
          if (!canvas) {
            console.log("No canvas found for WebGL injection");
            return;
          }
          
          const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
          if (!gl) {
            console.log("No WebGL context found");
            return;
          }
          
          console.log("WebGL context acquired, attempting shader override...");
          
          // WebGL„ÅÆÈñ¢Êï∞„Çí„Ç™„Éº„Éê„Éº„É©„Ç§„ÉâÔºàÂÆüÈ®ìÁöÑÔºâ
          const originalShaderSource = gl.shaderSource;
          gl.shaderSource = function(shader, source) {
            if (source.includes('gl_FragColor') && !source.includes('gl_FrontFacing')) {
              console.log("Modifying fragment shader...");
              source = source.replace(
                /gl_FragColor\s*=\s*([^;]+);/g,
                `
                if (gl_FrontFacing) {
                  gl_FragColor = $1;
                } else {
                  gl_FragColor = vec4(1.0, 0.0, 0.0, ($1).a);
                }
                `
              );
            }
            return originalShaderSource.call(this, shader, source);
          };
          
          console.log("‚úì WebGL shader override installed");
          
        } catch (error) {
          console.error("WebGL shader injection failed:", error);
        }
      }
      
      // Ë£èÈù¢„Å´Ëâ≤„Çí„Å§„Åë„ÇãÈñ¢Êï∞
      async function addBackfaceColor() {
        console.log("Starting backface color application...");
        
        try {
          // model-viewer„ÅåÂÆåÂÖ®„Å´Ë™≠„ÅøËæº„Åæ„Çå„Çã„Åæ„ÅßÂæÖÊ©ü
          await modelViewer.updateComplete;
          
          if (!modelViewer.model) {
            console.log("Model not available yet, retrying...");
            setTimeout(() => addBackfaceColor(), 300);
            return;
          }
          
          const model = modelViewer.model;
          console.log("Model object:", model);
          console.log("Model constructor:", model.constructor.name);
          console.log("Model keys:", Object.keys(model));
          console.log("Model type:", model.type);
          
          // „Éó„É≠„Éë„ÉÜ„Ç£„ÇíË©≥Á¥∞„Å´Ë™øÊüª
          for (let key in model) {
            if (model.hasOwnProperty(key)) {
              console.log(`model.${key}:`, typeof model[key], model[key]);
            }
          }
          
          // ÂèØËÉΩÊÄß„ÅÆ„ÅÇ„Çã„Ç∑„Éº„É≥„Ç¢„ÇØ„Çª„ÇπÊñπÊ≥ï„ÇíÂÖ®„Å¶Ë©¶„Åô
          let scene = null;
          
          // ÊñπÊ≥ï1: Áõ¥Êé•scene„Éó„É≠„Éë„ÉÜ„Ç£
          if (model.scene && typeof model.scene.traverse === 'function') {
            scene = model.scene;
            console.log("‚úì Found scene via model.scene");
          }
          // ÊñπÊ≥ï2: scenes„Éó„É≠„Éë„ÉÜ„Ç£
          else if (model.scenes && model.scenes.length > 0 && typeof model.scenes[0].traverse === 'function') {
            scene = model.scenes[0];
            console.log("‚úì Found scene via model.scenes[0]");
          }
          // ÊñπÊ≥ï3: „É¢„Éá„É´Ëá™‰Ωì„Åå„Ç∑„Éº„É≥„ÅÆÂ†¥Âêà
          else if (model.children && typeof model.traverse === 'function') {
            scene = model;
            console.log("‚úì Using model directly as scene");
          }
          // ÊñπÊ≥ï4: node„Éó„É≠„Éë„ÉÜ„Ç£
          else if (model.node && typeof model.node.traverse === 'function') {
            scene = model.node;
            console.log("‚úì Found scene via model.node");
          }
          // ÊñπÊ≥ï5: root„Éó„É≠„Éë„ÉÜ„Ç£
          else if (model.root && typeof model.root.traverse === 'function') {
            scene = model.root;
            console.log("‚úì Found scene via model.root");
          }
          // ÊñπÊ≥ï6: ‰ªñ„ÅÆÂèØËÉΩÊÄß
          else {
            console.log("Checking all properties for traverse method...");
            for (let key in model) {
              if (model[key] && typeof model[key].traverse === 'function') {
                scene = model[key];
                console.log(`‚úì Found scene via model.${key}`);
                break;
              }
            }
          }
          
          if (!scene) {
            console.error("‚ùå No traversable scene found in model");
            console.log("Attempting manual processing...");
            processNodeManually(model);
            return;
          }
          
          console.log("Scene object:", scene);
          console.log("Scene type:", scene.type);
          console.log("Scene children:", scene.children ? scene.children.length : 'none');
          
          let processedCount = 0;
          
          scene.traverse((node) => {
            if (node.isMesh && node.material) {
              processedCount++;
              console.log(`Processing mesh ${processedCount}:`, node.name || 'unnamed');
              
              const materials = Array.isArray(node.material) ? node.material : [node.material];
              
              materials.forEach((material, index) => {
                if (material) {
                  console.log(`Processing material ${index}:`, material.type);
                  
                  // ‰∏°Èù¢Ë°®Á§∫„ÇíÊúâÂäπ„Å´„Åô„Çã
                  material.side = 2; // THREE.DoubleSide
                  
                  // „Ç´„Çπ„Çø„É†„Ç∑„Çß„Éº„ÉÄ„Éº„ÅßË£èÈù¢„Å´Ëâ≤„Çí„Å§„Åë„Çã
                  material.onBeforeCompile = function(shader) {
                    console.log("Compiling shader for material:", material.name || index);
                    
                    shader.fragmentShader = shader.fragmentShader.replace(
                      '#include <output_fragment>',
                      `
                      #include <output_fragment>
                      
                      if ( !gl_FrontFacing ) {
                        gl_FragColor = vec4( 1.0, 0.0, 0.0, gl_FragColor.a );
                      }
                      `
                    );
                  };
                  
                  material.needsUpdate = true;
                  console.log(`‚úì Material ${index} processed`);
                }
              });
            }
          });
          
          console.log(`‚úÖ Successfully processed ${processedCount} meshes`);
          
        } catch (error) {
          console.error("‚ùå Error in addBackfaceColor:", error);
        }
      }
      
      // ÊâãÂãï„Åß„Éé„Éº„Éâ„ÇíÂá¶ÁêÜ„Åô„ÇãÈñ¢Êï∞
      function processNodeManually(node, depth = 0) {
        const indent = "  ".repeat(depth);
        console.log(`${indent}Processing node:`, node.constructor.name, node.type || 'unknown', node.name || 'unnamed');
        
        let processedCount = 0;
        
        // „É°„ÉÉ„Ç∑„É•„Åã„Å©„ÅÜ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if (node.isMesh && node.material) {
          processedCount++;
          console.log(`${indent}‚úì Found mesh:`, node.name || 'unnamed');
          
          const materials = Array.isArray(node.material) ? node.material : [node.material];
          
          materials.forEach((material, index) => {
            if (material) {
              console.log(`${indent}  Processing material ${index}:`, material.type);
              
              // ‰∏°Èù¢Ë°®Á§∫„ÇíÊúâÂäπ„Å´„Åô„Çã
              material.side = 2; // THREE.DoubleSide
              
              // „Ç´„Çπ„Çø„É†„Ç∑„Çß„Éº„ÉÄ„Éº„ÅßË£èÈù¢„Å´Ëâ≤„Çí„Å§„Åë„Çã
              material.onBeforeCompile = function(shader) {
                console.log(`${indent}  Compiling shader for material:`, material.name || index);
                
                shader.fragmentShader = shader.fragmentShader.replace(
                  '#include <output_fragment>',
                  `
                  #include <output_fragment>
                  
                  if ( !gl_FrontFacing ) {
                    gl_FragColor = vec4( 1.0, 0.0, 0.0, gl_FragColor.a );
                  }
                  `
                );
              };
              
              material.needsUpdate = true;
              console.log(`${indent}  ‚úì Material ${index} processed`);
            }
          });
        }
        
        // Â≠ê„Éé„Éº„Éâ„ÇíÂÜçÂ∏∞ÁöÑ„Å´Âá¶ÁêÜ
        if (node.children && node.children.length > 0) {
          console.log(`${indent}Found ${node.children.length} children`);
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childProcessed = processNodeManually(child, depth + 1);
            processedCount += childProcessed;
          }
        }
        
        // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇÇ„ÉÅ„Çß„ÉÉ„ÇØ
        for (let key in node) {
          if (key !== 'children' && node[key] && typeof node[key] === 'object' && node[key].constructor && node[key].constructor.name) {
            if (node[key].isMesh || (node[key].children && node[key].children.length > 0)) {
              console.log(`${indent}Checking property ${key}:`, node[key].constructor.name);
              const propProcessed = processNodeManually(node[key], depth + 1);
              processedCount += propProcessed;
            }
          }
        }
        
        if (depth === 0) {
          console.log(`‚úÖ Manual processing complete. Processed ${processedCount} meshes total.`);
        }
        
        return processedCount;
      }
      
      // ‰ª£Êõø„Ç¢„Éó„É≠„Éº„ÉÅÔºöThree.js„É¨„É≥„ÉÄ„É©„Éº„Å´Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ
      function tryAlternativeApproach() {
        console.log("üîÑ Trying alternative approach...");
        
        try {
          // Shadow DOM„Åã„Çâcanvas„ÇíÂèñÂæó
          const shadowRoot = modelViewer.shadowRoot;
          if (!shadowRoot) {
            console.log("No shadow root found");
            return;
          }
          
          const canvas = shadowRoot.querySelector('canvas');
          if (!canvas) {
            console.log("No canvas found in shadow root");
            return;
          }
          
          console.log("Canvas found:", canvas);
          
          // WebGL„É¨„É≥„ÉÄ„É™„É≥„Ç∞„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÂèñÂæó
          const gl = canvas.getContext('webgl') || canvas.getContext('webgl2');
          if (!gl) {
            console.log("No WebGL context found");
            return;
          }
          
          console.log("WebGL context found");
          
          // model-viewer„ÅÆÂÜÖÈÉ®API„Çí‰ΩøÁî®ÔºàÂÆüÈ®ìÁöÑÔºâ
          if (modelViewer.model && modelViewer.model.scene) {
            console.log("‚úì Found scene via model.scene in alternative approach");
            processSceneAlternative(modelViewer.model.scene);
            return;
          }
          
          // „Çà„ÇäÊ∑±„ÅÑ„É¨„Éô„É´„Åß„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÇíË©¶Ë°å
          const allProperties = getAllProperties(modelViewer);
          console.log("All model-viewer properties:", allProperties);
          
          // Three.js„ÅÆ„Ç∑„Éº„É≥„ÇíÊé¢„Åô
          for (let prop of allProperties) {
            try {
              const value = getNestedProperty(modelViewer, prop);
              if (value && typeof value.traverse === 'function') {
                console.log(`‚úì Found traversable object at: ${prop}`);
                processSceneAlternative(value);
                break;
              }
            } catch (e) {
              // „Éó„É≠„Éë„ÉÜ„Ç£„Ç¢„ÇØ„Çª„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
            }
          }
          
        } catch (error) {
          console.error("Error in alternative approach:", error);
        }
      }
      
      // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂÖ®„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÂÜçÂ∏∞ÁöÑ„Å´ÂèñÂæó
      function getAllProperties(obj, prefix = '', depth = 0, maxDepth = 3) {
        const properties = [];
        if (depth > maxDepth) return properties;
        
        try {
          for (let key in obj) {
            const fullPath = prefix ? `${prefix}.${key}` : key;
            properties.push(fullPath);
            
            if (obj[key] && typeof obj[key] === 'object' && depth < maxDepth) {
              properties.push(...getAllProperties(obj[key], fullPath, depth + 1, maxDepth));
            }
          }
        } catch (e) {
          // „Éó„É≠„Éë„ÉÜ„Ç£„Ç¢„ÇØ„Çª„Çπ„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ
        }
        
        return properties;
      }
      
      // „Éç„Çπ„Éà„Åó„Åü„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÂÆâÂÖ®„Å´ÂèñÂæó
      function getNestedProperty(obj, path) {
        return path.split('.').reduce((current, key) => {
          return current && current[key] !== undefined ? current[key] : null;
        }, obj);
      }
      
      // ‰ª£ÊõøÁöÑ„Å™„Ç∑„Éº„É≥Âá¶ÁêÜ
      function processSceneAlternative(scene) {
        console.log("üéØ Processing scene with alternative method");
        
        if (!scene || typeof scene.traverse !== 'function') {
          console.log("Invalid scene for alternative processing");
          return;
        }
        
        let meshCount = 0;
        
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`üîß Alternative processing mesh ${meshCount}:`, node.name || 'unnamed');
            
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                // „Çà„ÇäÂº∑Âäõ„Å™„Ç∑„Çß„Éº„ÉÄ„ÉºÁΩÆÊèõ
                material.side = 2; // DoubleSide
                
                const originalOnBeforeCompile = material.onBeforeCompile;
                material.onBeforeCompile = function(shader) {
                  if (originalOnBeforeCompile) {
                    originalOnBeforeCompile.call(this, shader);
                  }
                  
                  // „Çà„ÇäÁ¢∫ÂÆü„Å™„Ç∑„Çß„Éº„ÉÄ„ÉºÁΩÆÊèõ
                  if (shader.fragmentShader.includes('gl_FragColor')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /gl_FragColor\s*=\s*([^;]+);/g,
                      `
                      if (gl_FrontFacing) {
                        gl_FragColor = $1;
                      } else {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, ($1).a);
                      }
                      `
                    );
                  } else {
                    // outputColor„Çí‰ΩøÁî®„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà
                    shader.fragmentShader = shader.fragmentShader.replace(
                      '#include <output_fragment>',
                      `
                      #include <output_fragment>
                      if (!gl_FrontFacing) {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, gl_FragColor.a);
                      }
                      `
                    );
                  }
                  
                  console.log(`üé® Alternative shader compiled for material:`, material.name || index);
                };
                
                material.needsUpdate = true;
              }
            });
          }
        });
        
        console.log(`üéâ Alternative approach processed ${meshCount} meshes`);
      }

      // URL„Éë„É©„É°„Éº„Çø„Åã„Çâ„É¢„Éá„É´URL„ÇíÂèñÂæó
      function getModelUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("src");
      }

      // ÂàùÊúüÂåñ
      document.addEventListener("DOMContentLoaded", () => {
        updateBackgroundColor();

        // URL„Éë„É©„É°„Éº„Çø„Å´„É¢„Éá„É´URL„Åå„ÅÇ„Çå„Å∞Ë™≠„ÅøËæº„Åø
        const modelUrl = getModelUrlFromParams();
        if (modelUrl) {
          console.log("Loading model from URL parameter:", modelUrl);
          loadSampleModel(modelUrl);
        } else {
          // default.glb„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
          checkDefaultModel();
        }
      });

      // default.glb„ÅÆÂ≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ
      async function checkDefaultModel() {
        try {
          const response = await fetch('./default.glb', { method: 'HEAD' });
          if (response.ok) {
            // default.glb„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà
            console.log("Loading default.glb");
            modelViewer.src = "./default.glb";
          } else {
            // default.glb„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÄÅArweave„ÅÆ„É¢„Éá„É´„Çí‰ΩøÁî®
            console.log("default.glb not found, using fallback model");
            modelViewer.src = "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
          }
        } catch (error) {
          // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„Åæ„Åü„ÅØ„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà
          console.log("default.glb not accessible, using fallback model");
          modelViewer.src = "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
        }
      }

      // Â§ñÈÉ®„ÇØ„É™„ÉÉ„ÇØ„Åß„Ç≥„É≥„Éà„É≠„Éº„É´„Éë„Éç„É´„ÇíÈñâ„Åò„Çã
      document.addEventListener("click", (e) => {
        if (
          !lightControls.contains(e.target) &&
          !lightControlButton.contains(e.target)
        ) {
          if (showControls) {
            showControls = false;
            lightControls.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
