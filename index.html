<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2025 bon-soleil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project includes code from the following third-party libraries:

1. **lit (by Google LLC)**
   License: BSD 3-Clause

   Copyright 2017 Google LLC
   SPDX-License-Identifier: BSD-3-Clause

   https://github.com/lit/lit/blob/main/LICENSE

2. **Three.js**
   License: MIT License

   Copyright 2010-2024 Three.js Authors
   SPDX-License-Identifier: MIT


-->
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer</title>
    <script type="module" src="./model-viewer.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background-color: #000000;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
        background-color: #000000;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: #000000;
        --progress-bar-color: #007bff;
        --progress-mask: transparent;
        display: block;
        background-color: var(--poster-color);
      }

      /* カスタムプログレスバー */
      .custom-progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .progress-text {
        font-size: 14px;
        color: #333;
        font-weight: 500;
      }

      .progress-bar-track {
        width: 200px;
        height: 6px;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
        width: 0%;
      }

      .progress-percent {
        font-size: 12px;
        color: #666;
        font-weight: 500;
      }

      @keyframes progressPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* ライトコントロールボタン */
      .light-control-button {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .light-control-button svg {
        width: 28px;
        height: 28px;
        fill: #333;
      }

      .light-control-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* ライトコントロールパネル */
      .light-controls {
        position: absolute;
        top: 15px;
        right: 65px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 100;
        min-width: 200px;
        display: none;
      }

      .control-group {
        margin-bottom: 12px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .preset-buttons {
        display: flex;
        gap: 5px;
        margin-top: 10px;
      }

      .preset-button {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preset-button:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }

      /* 背景切り替えボタン */
      .background-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .bg-button {
        width: 32px;
        height: 32px;
        border: 2px solid #ddd;
        border-radius: 50%;
        background: transparent;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .bg-button.active {
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
      }

      .bg-button:hover {
        border-color: #007bff;
        transform: scale(1.1);
      }

      .bg-black {
        background: #000;
      }

      .bg-white {
        background: #fff;
        border-color: #ccc;
      }

      .bg-white.active {
        border-color: #007bff;
      }

      /* コントロールヒント */
      .controls-hint {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .container:hover .controls-hint {
        opacity: 1;
      }

      .controls-hint p {
        margin: 0;
        opacity: 0.9;
      }

      /* エラー表示 */
      .error-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 300px;
        padding: 40px 20px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-text {
        max-width: 400px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc3545;
        margin: 0 0 8px 0;
      }

      .error-message {
        font-size: 14px;
        color: #666;
        margin: 0 0 20px 0;
        line-height: 1.4;
      }

      .viewer-link {
        display: inline-block;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .viewer-link:hover {
        background-color: #0056b3;
        color: white;
        text-decoration: none;
      }

      /* モバイル対応 */
      @media (max-width: 768px) {
        .light-controls {
          right: 10px;
          top: 65px;
          min-width: 180px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- モデルビューアー -->
      <model-viewer
        id="modelViewer"
        alt="goodsun | bon-soleil"
        camera-controls
        loading="eager"
        reveal="auto"
        exposure="0.7"
        shadow-intensity="0.7"
        shadow-softness="0.3"
        style="--poster-color: #000000; background-color: #000000"
        camera-orbit="0deg 75deg 105%"
        field-of-view="30deg"
        min-camera-orbit="auto auto auto"
        max-camera-orbit="auto auto auto"
        min-field-of-view="10deg"
        max-field-of-view="45deg"
        autoplay
        animation-crossfade-duration="300ms"
      >
        <!-- プログレスバーを無効化 -->
        <div slot="progress-bar"></div>

        <!-- カスタムプログレスバー -->
        <div class="custom-progress-bar" id="customProgressBar">
          <div class="progress-text">Loading 3D Model...</div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
          <div class="progress-percent" id="progressPercent">0%</div>
        </div>
      </model-viewer>

      <!-- ライトコントロールボタン -->
      <button
        class="light-control-button"
        id="lightControlButton"
        title="Light Controls"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
          />
        </svg>
      </button>

      <!-- ライトコントロールパネル -->
      <div class="light-controls" id="lightControls">
        <div class="control-group">
          <label class="control-label">
            Brightness: <span id="exposureValue">70</span>%
          </label>
          <input
            type="range"
            min="0.1"
            max="2.0"
            step="0.1"
            value="0.7"
            id="exposureSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">
            Shadow: <span id="shadowValue">70</span>%
          </label>
          <input
            type="range"
            min="0"
            max="2.0"
            step="0.1"
            value="0.7"
            id="shadowSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">Background</label>
          <div class="background-toggle">
            <button
              id="bgBlackBtn"
              class="bg-button bg-black active"
              title="Black background"
            >
              ⚫
            </button>
            <button
              id="bgWhiteBtn"
              class="bg-button bg-white"
              title="White background"
            >
              ⚪
            </button>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-button" onclick="setPreset(0.5, 0.3)">
            Dim
          </button>
          <button class="preset-button" onclick="setPreset(0.7, 0.7)">
            Normal
          </button>
          <button class="preset-button" onclick="setPreset(1.5, 1.2)">
            Bright
          </button>
        </div>
      </div>

      <!-- コントロールヒント -->
      <div class="controls-hint">
        <p>Drag to rotate • Scroll to zoom • Right-click to pan</p>
      </div>
    </div>

    <script>
      const modelViewer = document.getElementById("modelViewer");
      const lightControlButton = document.getElementById("lightControlButton");
      const lightControls = document.getElementById("lightControls");
      const customProgressBar = document.getElementById("customProgressBar");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPercent = document.getElementById("progressPercent");
      const exposureSlider = document.getElementById("exposureSlider");
      const shadowSlider = document.getElementById("shadowSlider");
      const exposureValue = document.getElementById("exposureValue");
      const shadowValue = document.getElementById("shadowValue");
      const bgBlackBtn = document.getElementById("bgBlackBtn");
      const bgWhiteBtn = document.getElementById("bgWhiteBtn");

      let showControls = false;
      let currentBackgroundColor = "black";

      // ライトコントロールの表示/非表示
      lightControlButton.addEventListener("click", () => {
        showControls = !showControls;
        lightControls.style.display = showControls ? "block" : "none";
      });

      // モデル読み込み完了
      modelViewer.addEventListener("load", () => {
        console.log("Model loaded successfully");
        updateBackgroundColor();

        // 裏面に色をつける - 複数のアプローチを順次試行
        setTimeout(() => {
          addBackfaceColorSimple();
        }, 500);
      });

      modelViewer.addEventListener("error", (event) => {
        console.error("🚨 Model loading error detected:", event.detail);
        console.error("🚨 Current model src:", modelViewer.src);
        console.error("🚨 Error event object:", event);
        
        customProgressBar.style.display = "none";

        // エラー表示
        let errorMsg = "Failed to load 3D model";
        if (event.detail) {
          if (event.detail.type === "loadfailure") {
            // sourceErrorをチェックしてより詳細なエラーメッセージを生成
            if (event.detail.sourceError) {
              const sourceError = event.detail.sourceError;
              console.error("🚨 Source error:", sourceError);
              
              // TypeError: Failed to fetchはCORSまたはネットワークエラー
              if (sourceError.message && sourceError.message.includes("Failed to fetch")) {
                errorMsg = "Network error or CORS policy blocked the request";
                console.error("🚨 CORS/Network error detected");
              } else if (
                sourceError.message &&
                sourceError.message.includes("Invalid typed array length")
              ) {
                errorMsg = "Model file is too large for browser memory";
              } else if (
                sourceError.message &&
                sourceError.message.includes("texture")
              ) {
                errorMsg = "Failed to load model textures";
              } else if (
                sourceError.message &&
                sourceError.message.includes("scene")
              ) {
                errorMsg = "Model file is corrupted or incompatible format";
              } else {
                errorMsg = `Model loading failed: ${sourceError.message || "Unknown error"}`;
              }
            } else {
              errorMsg = "Model file is corrupted or incompatible";
              console.error("🚨 Load failure detected without source error");
            }
          } else if (event.detail.sourceError) {
            const sourceError = event.detail.sourceError;
            console.error("🚨 Source error without loadfailure:", sourceError);
            errorMsg = `Model loading error: ${sourceError.message || "Unknown error"}`;
          }
        }

        console.error("🚨 Final error message:", errorMsg);
        console.error("🚨 Model URL:", modelViewer.src);
        showError(errorMsg, modelViewer.src);
      });

      // タイムアウト監視を追加
      let loadingTimeout;
      
      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        console.log(`📊 Loading progress: ${(progress * 100).toFixed(1)}%`);

        progressBarFill.style.width = `${progress * 100}%`;
        progressPercent.textContent = `${Math.round(progress * 100)}%`;

        // タイムアウトをリセット
        clearTimeout(loadingTimeout);
        
        // 進行が止まった場合のタイムアウト（30秒）
        loadingTimeout = setTimeout(() => {
          console.error("🚨 Loading timeout detected - no progress for 30 seconds");
          if (progress < 1.0) {
            console.error("🚨 Calling showError due to timeout");
            showError("Loading timed out - possible network or memory issue", modelViewer.src);
          }
        }, 30000);

        // 100%になったら即座に非表示
        if (progress >= 1.0) {
          customProgressBar.style.display = "none";
          clearTimeout(loadingTimeout);
        } else {
          customProgressBar.style.display = "flex";
        }
      });


      // スライダーイベント
      exposureSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.exposure = value;
        exposureValue.textContent = Math.round(value * 100);
      });

      shadowSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.shadowIntensity = value;
        shadowValue.textContent = Math.round(value * 100);
      });

      // 背景色変更
      bgBlackBtn.addEventListener("click", () => {
        currentBackgroundColor = "black";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      bgWhiteBtn.addEventListener("click", () => {
        currentBackgroundColor = "white";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      function updateBackgroundButtons() {
        bgBlackBtn.classList.toggle(
          "active",
          currentBackgroundColor === "black"
        );
        bgWhiteBtn.classList.toggle(
          "active",
          currentBackgroundColor === "white"
        );
      }

      function updateBackgroundColor() {
        const bgColor =
          currentBackgroundColor === "black" ? "#000000" : "#ffffff";
        modelViewer.style.setProperty("--poster-color", bgColor);
        modelViewer.style.backgroundColor = bgColor;

        // Shadow rootのcanvasにも適用
        setTimeout(() => {
          const shadowRoot = modelViewer.shadowRoot;
          if (shadowRoot) {
            const canvas = shadowRoot.querySelector("canvas");
            if (canvas) {
              canvas.style.backgroundColor = bgColor;
            }
          }
        }, 100);
      }

      // プリセット設定
      function setPreset(exposure, shadow) {
        exposureSlider.value = exposure;
        shadowSlider.value = shadow;
        modelViewer.exposure = exposure;
        modelViewer.shadowIntensity = shadow;
        exposureValue.textContent = Math.round(exposure * 100);
        shadowValue.textContent = Math.round(shadow * 100);
      }

      // サンプルモデル読み込み
      function loadSampleModel(url) {
        console.log("Loading model:", url);
        
        // URLの検証
        if (!isValidModelUrl(url)) {
          showError("Invalid model URL or unsupported file format", url);
          return;
        }
        
        modelViewer.src = url;
        customProgressBar.style.display = "flex";
        clearError();
      }
      
      // モデルURLの検証
      function isValidModelUrl(url) {
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          
          // 対応している拡張子をチェック
          const validExtensions = ['.glb', '.gltf'];
          const hasValidExtension = validExtensions.some(ext => pathname.endsWith(ext));
          
          if (!hasValidExtension) {
            console.error("🚨 Invalid file extension. Supported formats: .glb, .gltf");
            return false;
          }
          
          // プロトコルのチェック
          if (!['http:', 'https:'].includes(urlObj.protocol)) {
            console.error("🚨 Invalid protocol. Only HTTP/HTTPS is supported");
            return false;
          }
          
          return true;
        } catch (e) {
          console.error("🚨 Invalid URL:", e);
          return false;
        }
      }

      // メモリ・ストレージ容量をチェック
      function checkMemoryAndStorage() {
        const issues = [];
        
        // 利用可能メモリの推定
        if (navigator.deviceMemory && navigator.deviceMemory < 4) {
          issues.push('デバイスメモリが不足している可能性があります');
        }
        
        // ローカルストレージ容量チェック
        try {
          const testKey = 'storage_test_' + Date.now();
          const testData = 'x'.repeat(1024 * 1024); // 1MBのテストデータ
          localStorage.setItem(testKey, testData);
          localStorage.removeItem(testKey);
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            issues.push('ローカルストレージの容量が不足しています');
          }
        }
        
        // ヒープメモリ使用量チェック（Chrome限定）
        if (performance.memory) {
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          if (memoryRatio > 0.8) {
            issues.push('ブラウザのメモリ使用量が高すぎます');
          }
        }
        
        return issues;
      }
      
      // ローカルストレージとキャッシュをクリア
      function clearStorageAndReload() {
        try {
          // ローカルストレージクリア
          localStorage.clear();
          
          // セッションストレージクリア
          sessionStorage.clear();
          
          // IndexedDBもクリア（可能であれば）
          if ('indexedDB' in window) {
            indexedDB.databases().then(databases => {
              databases.forEach(db => {
                indexedDB.deleteDatabase(db.name);
              });
            }).catch(() => {
              console.log('IndexedDB clear failed (may not be supported)');
            });
          }
          
          // キャッシュAPIクリア（Service Worker使用時）
          if ('caches' in window) {
            caches.keys().then(names => {
              names.forEach(name => {
                caches.delete(name);
              });
            });
          }
          
          console.log('Storage cleared successfully');
          
          // 2秒後にページを再読み込み
          setTimeout(() => {
            window.location.reload(true);
          }, 2000);
          
          return true;
        } catch (error) {
          console.error('Storage clear failed:', error);
          return false;
        }
      }

      // エラー表示
      function showError(message, modelUrl) {
        const container = document.querySelector(".container");
        const isInWebView = detectWebView();
        const memoryIssues = checkMemoryAndStorage();
        
        // メモリ・ストレージ問題がある場合の特別対応
        let storageActions = '';
        if (memoryIssues.length > 0) {
          storageActions = `
            <div style="margin: 15px 0; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; border-radius: 4px;">
              <p style="font-size: 12px; color: #856404; margin: 0 0 8px 0;"><strong>検出された問題:</strong></p>
              ${memoryIssues.map(issue => `<p style="font-size: 11px; color: #856404; margin: 2px 0;">• ${issue}</p>`).join('')}
            </div>
            <button onclick="clearStorageAndReload()" class="viewer-link" style="background: #ffc107; color: #000; margin-bottom: 8px;">
              🗑️ ストレージをクリアして再読み込み
            </button>
          `;
        }
        
        // WebView内かどうかに応じてボタンの表示を変更
        let buttonContent = '';
        let helpMessage = '';
        
        if (isInWebView) {
          buttonContent = `
            <button onclick="openInDefaultBrowser('${modelUrl}')" class="viewer-link">
              📋 URLをコピーして標準ブラウザで開く
            </button>
          `;
          helpMessage = 'このアプリ内ブラウザでは3D表示に制限があります。標準ブラウザ（Chrome、Safari等）で開いてください。';
        } else {
          buttonContent = `
            <button onclick="window.location.reload()" class="viewer-link">
              🔄 ページを再読み込み
            </button>
          `;
          helpMessage = 'ブラウザのメモリ不足またはローカルストレージの問題が原因の可能性があります。';
        }
        
        container.innerHTML = `
                <div class="error-display">
                    <div class="error-icon">⚠️</div>
                    <div class="error-text">
                        <p class="error-title">3D Model Loading Error</p>
                        <p class="error-message">${message}</p>
                        <p class="error-message" style="font-size: 12px; color: #888; margin-top: 10px;">
                          ${helpMessage}
                        </p>
                        ${storageActions}
                        ${buttonContent}
                        ${!isInWebView ? `<button onclick="clearStorageAndReload()" class="viewer-link" style="background: #6c757d; margin-top: 5px;">
                          🏠 ストレージクリア後ホームに戻る
                        </button>` : ''}
                    </div>
                </div>
            `;
      }

      function clearError() {
        // エラー表示をクリア（必要に応じて実装）
      }

      // WebView環境の検出（シンプル版）
      function detectWebView() {
        const userAgent = navigator.userAgent;
        
        // 主要なWebViewパターンのみ
        const webViewPatterns = [
          /wv/i,           // Android WebView
          /WebView/i,      // 汎用WebView
          /FBAN|FBAV/i,   // Facebook内ブラウザ
          /Line/i,         // LINE内ブラウザ
          /Instagram/i,    // Instagram内ブラウザ
          /Twitter/i       // Twitter内ブラウザ
        ];
        
        return webViewPatterns.some(pattern => pattern.test(userAgent));
      }

      // 標準ブラウザでURLを開く
      function openInDefaultBrowser(modelUrl) {
        const currentUrl = window.location.href;
        const baseUrl = currentUrl.split('?')[0];
        const fullUrl = `${baseUrl}?src=${encodeURIComponent(modelUrl)}`;
        
        console.log('Attempting to open in default browser:', fullUrl);
        
        // モバイル環境の判定
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        // 1. Androidの場合、インテントURLを試行
        if (isAndroid) {
          const intentUrl = `intent://${fullUrl.replace(/^https?:\/\//, '')}#Intent;action=android.intent.action.VIEW;scheme=https;end`;
          window.location.href = intentUrl;
          
          // フォールバック: 3秒後にクリップボードコピー
          setTimeout(() => {
            copyToClipboardAndNotify(fullUrl);
          }, 3000);
          return;
        }
        
        // 2. iOSの場合、window.openを試行
        if (isIOS) {
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ポップアップがブロックされた場合
            copyToClipboardAndNotify(fullUrl);
          }
          return;
        }
        
        // 3. デスクトップまたはその他の環境
        try {
          // 新しいタブで開く
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ポップアップがブロックされた場合
            copyToClipboardAndNotify(fullUrl);
          }
        } catch (e) {
          // エラーの場合はクリップボードにコピー
          copyToClipboardAndNotify(fullUrl);
        }
      }

      // クリップボードにコピーしてユーザーに通知
      function copyToClipboardAndNotify(url) {
        console.log('Copying to clipboard:', url);
        
        // 複数の方法でクリップボードコピーを試行
        if (navigator.clipboard && navigator.clipboard.writeText) {
          // 最新のClipboard API
          navigator.clipboard.writeText(url).then(() => {
            console.log('Copied using Clipboard API');
            showCopySuccessAlert(url);
          }).catch(() => {
            console.log('Clipboard API failed, trying fallback');
            fallbackCopyToClipboard(url);
          });
        } else {
          // フォールバック方法
          fallbackCopyToClipboard(url);
        }
      }

      // フォールバック方法でクリップボードにコピー
      function fallbackCopyToClipboard(url) {
        try {
          // 方法1: document.execCommand（古いブラウザ対応）
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.select();
          textArea.setSelectionRange(0, 99999);
          
          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);
          
          if (successful) {
            console.log('Copied using execCommand');
            showCopySuccessAlert(url);
          } else {
            console.log('execCommand failed, showing prompt');
            showManualCopyPrompt(url);
          }
        } catch (error) {
          console.log('execCommand error:', error);
          showManualCopyPrompt(url);
        }
      }

      // コピー成功時のアラート表示
      function showCopySuccessAlert(url) {
        alert(`URLをクリップボードにコピーしました！\n標準ブラウザ（Chrome、Safari等）で貼り付けて開いてください。\n\nコピーされたURL:\n${url}`);
      }

      // 手動コピー用のプロンプト表示（無限ループ防止）
      function showManualCopyPrompt(url) {
        const userChoice = confirm(
          '自動コピーに失敗しました。\n\n' +
          '以下の方法で対処できます：\n' +
          '• OK: URLを表示してマニュアルコピー\n' +
          '• キャンセル: そのまま終了\n\n' +
          'URL: ' + url
        );
        
        if (userChoice) {
          // URLを表示するだけで、再試行はしない
          alert(
            'URLをコピーして標準ブラウザで開いてください：\n\n' + url + 
            '\n\n※このURLを選択してコピー（Ctrl+C / Cmd+C）してください'
          );
        }
      }

      // シンプルな裏面グレー着色機能
      function addBackfaceColorSimple() {
        console.log("🎯 Starting backface gray coloring...");

        // モデル読み込み完了まで少し待つ
        setTimeout(() => {
          console.log("Checking model availability...");
          console.log("modelViewer.model:", modelViewer.model);
          console.log("modelViewer properties:", Object.keys(modelViewer));
          
          // 複数の方法でモデルにアクセス
          let model = null;
          
          if (modelViewer.model) {
            model = modelViewer.model;
            console.log("✓ Found model via modelViewer.model");
          } else {
            // model-viewerの内部を探索
            console.log("⚠️ modelViewer.model not available, searching alternatives...");
            
            // Shadow DOMから探す
            const shadowRoot = modelViewer.shadowRoot;
            if (shadowRoot) {
              console.log("Found shadow root, searching for Three.js scene...");
              
              // 可能性のある内部プロパティを探す
              for (let key in modelViewer) {
                try {
                  const value = modelViewer[key];
                  if (value && typeof value === 'object') {
                    console.log(`Checking modelViewer.${key}:`, typeof value, value?.constructor?.name);
                    
                    if (value.scene || value.model || (value.children && value.traverse)) {
                      model = value;
                      console.log(`✓ Found model via modelViewer.${key}`);
                      break;
                    }
                  }
                } catch (e) {
                  // アクセスエラーは無視
                }
              }
            }
          }
          
          if (model) {
            processModelForBackface(model);
          } else {
            console.log("❌ No model found, retrying in 2 seconds...");
            setTimeout(() => addBackfaceColorSimple(), 2000);
          }
        }, 500);
      }

      // モデルの裏面をグレーに着色
      function processModelForBackface(model) {
        console.log("Processing model for backface gray coloring...");
        console.log("Model object:", model);
        console.log("Model properties:", Object.keys(model));
        console.log("Model constructor:", model.constructor.name);
        
        let scene = null;
        
        // より詳細にシーンを探す
        if (model.scene && typeof model.scene.traverse === 'function') {
          scene = model.scene;
          console.log("✓ Found scene via model.scene");
        } else if (model.children && typeof model.traverse === 'function') {
          scene = model;
          console.log("✓ Using model directly as scene");
        } else {
          console.log("⚠️ Standard scene access failed, searching deeper...");
          
          // Symbolプロパティを探索
          const symbols = Object.getOwnPropertySymbols(model);
          console.log(`Found ${symbols.length} symbol properties:`, symbols.map(s => s.toString()));
          
          for (let symbol of symbols) {
            try {
              const value = model[symbol];
              console.log(`Checking model[${symbol.toString()}]:`, typeof value, value?.constructor?.name);
              
              if (value && typeof value === 'object' && value.traverse && typeof value.traverse === 'function') {
                scene = value;
                console.log(`✓ Found scene via model[${symbol.toString()}]`);
                break;
              }
              
              // 配列の場合、各要素をチェック
              if (Array.isArray(value)) {
                console.log(`  Array with ${value.length} elements`);
                for (let i = 0; i < value.length; i++) {
                  const element = value[i];
                  console.log(`    Element [${i}]:`, typeof element, element?.constructor?.name);
                  
                  if (element && typeof element === 'object') {
                    // 要素の詳細を表示
                    console.log(`    Element [${i}] keys:`, Object.keys(element));
                    console.log(`    Element [${i}] symbols:`, Object.getOwnPropertySymbols(element).map(s => s.toString()));
                    
                    // traverseメソッドを持つか確認
                    if (element.traverse && typeof element.traverse === 'function') {
                      scene = element;
                      console.log(`✓ Found scene via model[${symbol.toString()}][${i}]`);
                      break;
                    }
                    
                    // Three.jsのシーンオブジェクトを探す
                    if (element.scene && element.scene.traverse) {
                      scene = element.scene;
                      console.log(`✓ Found scene via model[${symbol.toString()}][${i}].scene`);
                      break;
                    }
                    
                    // 一般的なThree.jsオブジェクトのプロパティをチェック
                    const threeJsProps = ['children', 'parent', 'geometry', 'material', 'matrix', 'position', 'rotation', 'scale'];
                    for (let prop of threeJsProps) {
                      if (element[prop] !== undefined) {
                        console.log(`    Element [${i}] has Three.js property: ${prop}`);
                        
                        // childrenプロパティがあり、traverseメソッドもある場合
                        if (prop === 'children' && element.traverse && typeof element.traverse === 'function') {
                          scene = element;
                          console.log(`✓ Found Three.js object with traverse via model[${symbol.toString()}][${i}]`);
                          break;
                        }
                      }
                    }
                    if (scene) break;
                    
                    // 要素のプロパティも再帰的に探す
                    for (let key in element) {
                      try {
                        const nestedValue = element[key];
                        if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                          scene = nestedValue;
                          console.log(`✓ Found scene via model[${symbol.toString()}][${i}].${key}`);
                          break;
                        }
                      } catch (e) {
                        // アクセスエラーは無視
                      }
                    }
                    if (scene) break;
                  }
                }
                if (scene) break;
              }
              
              // ネストしたオブジェクトも探す
              if (value && typeof value === 'object') {
                // 通常のプロパティ
                for (let nestedKey in value) {
                  try {
                    const nestedValue = value[nestedKey];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`✓ Found scene via model[${symbol.toString()}].${nestedKey}`);
                      break;
                    }
                  } catch (e) {
                    // アクセスエラーは無視
                  }
                }
                if (scene) break;
                
                // Symbolプロパティも探す
                const nestedSymbols = Object.getOwnPropertySymbols(value);
                for (let nestedSymbol of nestedSymbols) {
                  try {
                    const nestedValue = value[nestedSymbol];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`✓ Found scene via model[${symbol.toString()}][${nestedSymbol.toString()}]`);
                      break;
                    }
                  } catch (e) {
                    // アクセスエラーは無視
                  }
                }
                if (scene) break;
              }
            } catch (e) {
              console.log(`Cannot access model[${symbol.toString()}]:`, e.message);
            }
          }
          
          if (!scene) {
            console.log("❌ No traversable scene found after symbol search");
            return;
          }
        }

        let meshCount = 0;
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`Processing mesh ${meshCount}: ${node.name || 'unnamed'}`);

            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                console.log(`  Modifying material ${index}: ${material.type}`);
                
                // 元のマテリアルを保存
                const originalSide = material.side;
                const originalOnBeforeCompile = material.onBeforeCompile;
                
                // 両面表示を強制的に有効化
                material.side = 2; // THREE.DoubleSide
                
                // 透明度とカリング設定
                if (material.transparent === undefined) {
                  material.transparent = false;
                }
                
                // シェーダー修正で裏面をグレーに（確実版）
                material.onBeforeCompile = function (shader) {
                  console.log(`  Compiling shader for material ${index}`);
                  console.log(`  Original fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // 元のコンパイラも実行
                  if (originalOnBeforeCompile && typeof originalOnBeforeCompile === 'function') {
                    originalOnBeforeCompile.call(this, shader);
                  }
                  
                  // 確実にgl_FrontFacingチェックを追加
                  const backfaceCode = `
                    // 裏面ダークグレー着色
                    if (!gl_FrontFacing) {
                      gl_FragColor = vec4(0.2, 0.2, 0.2, 1.0);
                    }
                  `;
                  
                  // 複数の挿入ポイントを試行
                  let modified = false;
                  
                  // 1. output_fragment の後
                  if (shader.fragmentShader.includes('#include <output_fragment>')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /#include <output_fragment>/g,
                      `#include <output_fragment>\n${backfaceCode}`
                    );
                    modified = true;
                    console.log(`  ✓ Applied after output_fragment`);
                  }
                  
                  // 2. main関数の最後
                  if (!modified && shader.fragmentShader.includes('void main()')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /(void\s+main\s*\(\s*\)\s*{[\s\S]*?)(\s*}\s*)$/,
                      `$1${backfaceCode}$2`
                    );
                    modified = true;
                    console.log(`  ✓ Applied at end of main()`);
                  }
                  
                  // 3. 最終手段：シェーダーの最後
                  if (!modified) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /}\s*$/,
                      `${backfaceCode}\n}`
                    );
                    console.log(`  ✓ Applied at shader end (forced)`);
                  }
                  
                  console.log(`  Modified fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // デバッグ用：修正されたシェーダーの一部を表示
                  const lines = shader.fragmentShader.split('\n');
                  console.log(`  Last 5 lines of shader:`, lines.slice(-5));
                };
                
                material.needsUpdate = true;
                console.log(`  ✓ Material ${index} processed for gray backface (enhanced)`);
              }
            });
          }
        });

        console.log(`✅ Processed ${meshCount} meshes with gray backface coloring`);
      }

      // URLパラメータからモデルURLを取得
      function getModelUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("src");
      }

      // ブラウザの自動リロードを防止
      window.addEventListener('beforeunload', (event) => {
        console.log("🚨 Page unload detected - checking if intentional...");
        
        // メモリ不足などでの意図しないリロードを検出
        if (performance.memory) {
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          if (memoryRatio > 0.9) {
            console.error("🚨 High memory usage detected during unload:", memoryRatio);
            // ストレージをクリアしてから再読み込み
            localStorage.clear();
            sessionStorage.clear();
          }
        }
      });

      // エラー時の自動リロードを防止
      window.addEventListener('error', (event) => {
        console.error("🚨 Global error detected:", event.error);
        if (event.error && event.error.message) {
          if (event.error.message.includes('memory') || 
              event.error.message.includes('quota') ||
              event.error.message.includes('storage')) {
            console.error("🚨 Memory/Storage error - preventing automatic reload");
            event.preventDefault();
            showError("Memory or storage error detected", modelViewer.src || "unknown");
          }
        }
      });

      // 初期化
      document.addEventListener("DOMContentLoaded", () => {
        console.log("🚀 Page loaded, initializing...");
        updateBackgroundColor();

        // URLパラメータにモデルURLがあれば読み込み
        const modelUrl = getModelUrlFromParams();
        if (modelUrl) {
          console.log("📥 Loading model from URL parameter:", modelUrl);
          loadSampleModel(modelUrl);
        } else {
          console.log("🔍 No URL parameter, checking default model...");
          // default.glbが存在しない場合のフォールバック
          checkDefaultModel();
        }
        
        // 5分後に強制的にエラー画面を表示（デバッグ用）
        setTimeout(() => {
          if (!modelViewer.model && customProgressBar.style.display !== "none") {
            console.error("🚨 Force timeout after 5 minutes");
            showError("Loading took too long - please try again", modelViewer.src || "unknown");
          }
        }, 300000);
      });

      // default.glbの存在チェック
      async function checkDefaultModel() {
        try {
          const response = await fetch("./default.glb", { method: "HEAD" });
          if (response.ok) {
            // default.glbが存在する場合
            console.log("Loading default.glb");
            modelViewer.src = "./default.glb";
          } else {
            // default.glbが存在しない場合、Arweaveのモデルを使用
            console.log("default.glb not found, using fallback model");
            modelViewer.src =
              "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
          }
        } catch (error) {
          // ネットワークエラーまたはファイルが存在しない場合
          console.log("default.glb not accessible, using fallback model");
          modelViewer.src =
            "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
        }
      }

      // 外部クリックでコントロールパネルを閉じる
      document.addEventListener("click", (e) => {
        if (
          !lightControls.contains(e.target) &&
          !lightControlButton.contains(e.target)
        ) {
          if (showControls) {
            showControls = false;
            lightControls.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
